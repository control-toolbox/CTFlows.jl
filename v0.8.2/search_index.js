var documenterSearchIndex = {"docs":
[{"location":"api.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"api.html#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Pages   = [\"api.md\"]\nModules = [CTFlows]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api.html#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"","category":"page"},{"location":"dev.html#Private-functions","page":"Developers","title":"Private functions","text":"","category":"section"},{"location":"dev.html#Index","page":"Developers","title":"Index","text":"","category":"section"},{"location":"dev.html","page":"Developers","title":"Developers","text":"Pages   = [\"dev.md\"]\nModules = [CTFlows]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev.html#Documentation","page":"Developers","title":"Documentation","text":"","category":"section"},{"location":"dev.html#CTFlows.:⅋-Union{Tuple{V}, Tuple{CTFlows.VectorField{<:Function, CTFlows.Autonomous, V}, CTFlows.VectorField{<:Function, CTFlows.Autonomous, V}}} where V<:CTFlows.VariableDependence","page":"Developers","title":"CTFlows.:⅋","text":"⅋(\n    X::CTFlows.VectorField{<:Function, CTFlows.Autonomous, V<:CTFlows.VariableDependence},\n    Y::CTFlows.VectorField{<:Function, CTFlows.Autonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\n\"Directional derivative\" of a vector field: internal and only used to compute efficiently the Lie bracket of two vector fields, autonomous case\n\nExample\n\njulia> X = VectorField(x -> [x[2], -x[1]])\njulia> Y = VectorField(x -> [x[1], x[2]])\njulia> CTBase.:(⅋)(X, Y)([1, 2])\n[2, -1]\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.:⅋-Union{Tuple{V}, Tuple{CTFlows.VectorField{<:Function, CTFlows.NonAutonomous, V}, CTFlows.VectorField{<:Function, CTFlows.NonAutonomous, V}}} where V<:CTFlows.VariableDependence","page":"Developers","title":"CTFlows.:⅋","text":"⅋(\n    X::CTFlows.VectorField{<:Function, CTFlows.NonAutonomous, V<:CTFlows.VariableDependence},\n    Y::CTFlows.VectorField{<:Function, CTFlows.NonAutonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\n\"Directional derivative\" of a vector field: internal and only used to compute efficiently the Lie bracket of two vector fields, nonautonomous case\n\nExample\n\njulia> X = VectorField((t, x, v) -> [t + v[1] + v[2] + x[2], -x[1]], NonFixed, NonAutonomous)\njulia> Y = VectorField((t, x, v) ->  [v[1] + v[2] + x[1], x[2]], NonFixed, NonAutonomous)\njulia> CTBase.:(⅋)(X, Y)(1, [1, 2], [2, 3])\n[8, -1]\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.:⋅-Tuple{CTFlows.VectorField{<:Function, CTFlows.Autonomous}, Function}","page":"Developers","title":"CTFlows.:⋅","text":"⋅(\n    X::CTFlows.VectorField{<:Function, CTFlows.Autonomous},\n    f::Function\n) -> CTFlows.var\"#27#29\"{CTFlows.VectorField{var\"#s2\", CTFlows.Autonomous, var\"#s1\"}, <:Function} where {var\"#s2\"<:Function, var\"#s1\"<:CTFlows.VariableDependence}\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in autonomous case\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (X⋅f)([1, 2])\n0\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.:⋅-Tuple{CTFlows.VectorField{<:Function, CTFlows.NonAutonomous}, Function}","page":"Developers","title":"CTFlows.:⋅","text":"⋅(\n    X::CTFlows.VectorField{<:Function, CTFlows.NonAutonomous},\n    f::Function\n) -> CTFlows.var\"#31#33\"{CTFlows.VectorField{var\"#s26\", CTFlows.NonAutonomous, var\"#s2\"}, <:Function} where {var\"#s26\"<:Function, var\"#s2\"<:CTFlows.VariableDependence}\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in nonautonomous case\n\nExample\n\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (X⋅f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.:⋅-Tuple{Function, Function}","page":"Developers","title":"CTFlows.:⋅","text":"⋅(\n    X::Function,\n    f::Function\n) -> CTFlows.var\"#27#29\"{CTFlows.VectorField{var\"#s182\", CTFlows.Autonomous, CTFlows.Fixed}, <:Function} where var\"#s182\"<:Function\n\n\nLie derivative of a scalar function along a function. In this case both functions will be considered autonomous and non-variable.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (φ⋅f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (φ⋅f)(1, [1, 2], [2, 1])\nMethodError\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.Lie-Tuple{CTFlows.VectorField, Function}","page":"Developers","title":"CTFlows.Lie","text":"Lie(\n    X::CTFlows.VectorField,\n    f::Function\n) -> Union{CTFlows.var\"#27#29\"{CTFlows.VectorField{var\"#s2\", CTFlows.Autonomous, var\"#s1\"}, <:Function} where {var\"#s2\"<:Function, var\"#s1\"<:CTFlows.VariableDependence}, CTFlows.var\"#31#33\"{CTFlows.VectorField{var\"#s26\", CTFlows.NonAutonomous, var\"#s2\"}, <:Function} where {var\"#s26\"<:Function, var\"#s2\"<:CTFlows.VariableDependence}}\n\n\nLie derivative of a scalar function along a vector field.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(X,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(X, f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.Lie-Tuple{Function, Function}","page":"Developers","title":"CTFlows.Lie","text":"Lie(\n    X::Function,\n    f::Function;\n    autonomous,\n    variable\n) -> Union{CTFlows.var\"#27#29\"{CTFlows.VectorField{var\"#s2\", CTFlows.Autonomous, var\"#s1\"}, <:Function} where {var\"#s2\"<:Function, var\"#s1\"<:CTFlows.VariableDependence}, CTFlows.var\"#31#33\"{CTFlows.VectorField{var\"#s26\", CTFlows.NonAutonomous, var\"#s2\"}, <:Function} where {var\"#s26\"<:Function, var\"#s2\"<:CTFlows.VariableDependence}}\n\n\nLie derivative of a scalar function along a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, autonomous=false, variable=true)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.Lie-Union{Tuple{V}, Tuple{CTFlows.VectorField{<:Function, CTFlows.Autonomous, V}, CTFlows.VectorField{<:Function, CTFlows.Autonomous, V}}} where V<:CTFlows.VariableDependence","page":"Developers","title":"CTFlows.Lie","text":"Lie(\n    X::CTFlows.VectorField{<:Function, CTFlows.Autonomous, V<:CTFlows.VariableDependence},\n    Y::CTFlows.VectorField{<:Function, CTFlows.Autonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), autonomous case\n\nExample\n\njulia> f = x -> [x[2], 2x[1]]\njulia> g = x -> [3x[2], -x[1]]\njulia> X = VectorField(f)\njulia> Y = VectorField(g)\njulia> Lie(X, Y)([1, 2])\n[7, -14]\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.Lie-Union{Tuple{V}, Tuple{CTFlows.VectorField{<:Function, CTFlows.NonAutonomous, V}, CTFlows.VectorField{<:Function, CTFlows.NonAutonomous, V}}} where V<:CTFlows.VariableDependence","page":"Developers","title":"CTFlows.Lie","text":"Lie(\n    X::CTFlows.VectorField{<:Function, CTFlows.NonAutonomous, V<:CTFlows.VariableDependence},\n    Y::CTFlows.VectorField{<:Function, CTFlows.NonAutonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), nonautonomous case\n\nExample\n\njulia> f = (t, x, v) -> [t + x[2] + v, -2x[1] - v]\njulia> g = (t, x, v) -> [t + 3x[2] + v, -x[1] - v]\njulia> X = VectorField(f, NonAutonomous, NonFixed)\njulia> Y = VectorField(g, NonAutonomous, NonFixed)\njulia> Lie(X, Y)(1, [1, 2], 1)\n[-7,12]\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.Lift-Tuple{CTFlows.VectorField}","page":"Developers","title":"CTFlows.Lift","text":"Lift(\n    X::CTFlows.VectorField\n) -> CTFlows.HamiltonianLift{CTFlows.VectorField{TF, TD, VD}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\n\nReturn the HamiltonianLift of a VectorField.\n\nExample\n\njulia> HL = Lift(VectorField(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false))\njulia> HL([1, 0], [0, 1])\n0\njulia> HL = Lift(VectorField((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true))\njulia> HL(1, [1, 0], [0, 1], 1)\n1\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.Lift-Tuple{Function}","page":"Developers","title":"CTFlows.Lift","text":"Lift(\n    X::Function;\n    autonomous,\n    variable\n) -> CTFlows.var\"#19#23\"{<:Function}\n\n\nReturn the Lift of a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.Poisson-Tuple{Function, Function}","page":"Developers","title":"CTFlows.Poisson","text":"Poisson(\n    f::Function,\n    g::Function;\n    autonomous,\n    variable\n) -> CTFlows.Hamiltonian\n\n\nPoisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, autonomous=false, variable=true)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.Poisson-Union{Tuple{VD}, Tuple{TD}, Tuple{CTFlows.AbstractHamiltonian{TD, VD}, Function}} where {TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}","page":"Developers","title":"CTFlows.Poisson","text":"Poisson(\n    f::CTFlows.AbstractHamiltonian{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence},\n    g::Function\n) -> CTFlows.Hamiltonian\n\n\nPoisson bracket of an Hamiltonian function (subtype of AbstractHamiltonian) and a function : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> Poisson(F, g)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.Poisson-Union{Tuple{VD}, Tuple{TD}, Tuple{Function, CTFlows.AbstractHamiltonian{TD, VD}}} where {TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}","page":"Developers","title":"CTFlows.Poisson","text":"Poisson(\n    f::Function,\n    g::CTFlows.AbstractHamiltonian{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n) -> CTFlows.Hamiltonian\n\n\nPoisson bracket of a function and an Hamiltonian function (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> G = Hamiltonian(g)          \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(f, G)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.Poisson-Union{Tuple{V}, Tuple{CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V}, CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V}}} where V<:CTFlows.VariableDependence","page":"Developers","title":"CTFlows.Poisson","text":"Poisson(\n    f::CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V<:CTFlows.VariableDependence},\n    g::CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> G = Hamiltonian(g)\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.Poisson-Union{Tuple{V}, Tuple{CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V}, CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V}}} where V<:CTFlows.VariableDependence","page":"Developers","title":"CTFlows.Poisson","text":"Poisson(\n    f::CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V<:CTFlows.VariableDependence},\n    g::CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), non autonomous case\n\nExample\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n-76\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{CTFlows.HamiltonianLift{T, V}, CTFlows.HamiltonianLift{T, V}}} where {T<:CTFlows.TimeDependence, V<:CTFlows.VariableDependence}","page":"Developers","title":"CTFlows.Poisson","text":"Poisson(\n    f::CTFlows.HamiltonianLift{T<:CTFlows.TimeDependence, V<:CTFlows.VariableDependence},\n    g::CTFlows.HamiltonianLift{T<:CTFlows.TimeDependence, V<:CTFlows.VariableDependence}\n)\n\n\nPoisson bracket of two HamiltonianLift functions : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = x -> [x[1]^2+x[2]^2, 2x[1]^2]\njulia> g = x -> [3x[2]^2, x[2]-x[1]^2]\njulia> F = Lift(f)\njulia> G = Lift(g)\njulia> Poisson(F, G)([1, 2], [2, 1])\n-64\njulia> f = (t, x, v) -> [t*v[1]*x[2]^2, 2x[1]^2 + + v[2]]\njulia> g = (t, x, v) -> [3x[2]^2 + -x[1]^2, t - v[2]]\njulia> F = Lift(f, NonAutonomous, NonFixed)\njulia> G = Lift(g, NonAutonomous, NonFixed)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n100\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.makeH-Tuple{CTFlows.Dynamics, CTFlows.ControlLaw, CTFlows.Lagrange, Real, Real, CTFlows.MixedConstraint, CTFlows.Multiplier}","page":"Developers","title":"CTFlows.makeH","text":"makeH(\n    f::CTFlows.Dynamics,\n    u::CTFlows.ControlLaw,\n    f⁰::CTFlows.Lagrange,\n    p⁰::Real,\n    s::Real,\n    g::CTFlows.MixedConstraint,\n    μ::CTFlows.Multiplier\n) -> CTFlows.var\"#H#102\"{CTFlows.Dynamics{TF, TD, VD}, CTFlows.ControlLaw{TF1, TD1, VD1}, CTFlows.Lagrange{TF2, TD2, VD2}, var\"#s182\", var\"#s1821\", CTFlows.MixedConstraint{TF3, TD3, VD3}, CTFlows.Multiplier{TF4, TD4, VD4}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence, TF1<:Function, TD1<:CTFlows.TimeDependence, VD1<:CTFlows.VariableDependence, TF2<:Function, TD2<:CTFlows.TimeDependence, VD2<:CTFlows.VariableDependence, var\"#s182\"<:Real, var\"#s1821\"<:Real, TF3<:Function, TD3<:CTFlows.TimeDependence, VD3<:CTFlows.VariableDependence, TF4<:Function, TD4<:CTFlows.TimeDependence, VD4<:CTFlows.VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + s p⁰ f⁰(t, x, u(t, x, p)) + μ(t, x, p) ⋅ g(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.makeH-Tuple{CTFlows.Dynamics, CTFlows.ControlLaw, CTFlows.Lagrange, Real, Real}","page":"Developers","title":"CTFlows.makeH","text":"makeH(\n    f::CTFlows.Dynamics,\n    u::CTFlows.ControlLaw,\n    f⁰::CTFlows.Lagrange,\n    p⁰::Real,\n    s::Real\n) -> CTFlows.var\"#H#100\"{CTFlows.Dynamics{TF, TD, VD}, CTFlows.ControlLaw{TF1, TD1, VD1}, CTFlows.Lagrange{TF2, TD2, VD2}, <:Real, <:Real} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence, TF1<:Function, TD1<:CTFlows.TimeDependence, VD1<:CTFlows.VariableDependence, TF2<:Function, TD2<:CTFlows.TimeDependence, VD2<:CTFlows.VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + s p⁰ f⁰(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.makeH-Tuple{CTFlows.Dynamics, CTFlows.ControlLaw, CTFlows.MixedConstraint, CTFlows.Multiplier}","page":"Developers","title":"CTFlows.makeH","text":"makeH(\n    f::CTFlows.Dynamics,\n    u::CTFlows.ControlLaw,\n    g::CTFlows.MixedConstraint,\n    μ::CTFlows.Multiplier\n) -> CTFlows.var\"#H#101\"{CTFlows.Dynamics{TF, TD, VD}, CTFlows.ControlLaw{TF1, TD1, VD1}, CTFlows.MixedConstraint{TF2, TD2, VD2}, CTFlows.Multiplier{TF3, TD3, VD3}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence, TF1<:Function, TD1<:CTFlows.TimeDependence, VD1<:CTFlows.VariableDependence, TF2<:Function, TD2<:CTFlows.TimeDependence, VD2<:CTFlows.VariableDependence, TF3<:Function, TD3<:CTFlows.TimeDependence, VD3<:CTFlows.VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + μ(t, x, p) ⋅ g(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.makeH-Tuple{CTFlows.Dynamics, CTFlows.ControlLaw}","page":"Developers","title":"CTFlows.makeH","text":"makeH(\n    f::CTFlows.Dynamics,\n    u::CTFlows.ControlLaw\n) -> CTFlows.var\"#98#99\"{CTFlows.Dynamics{TF, TD, VD}, CTFlows.ControlLaw{TF1, TD1, VD1}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence, TF1<:Function, TD1<:CTFlows.TimeDependence, VD1<:CTFlows.VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p f(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.∂ₜ-Tuple{Any}","page":"Developers","title":"CTFlows.∂ₜ","text":"∂ₜ(f) -> CTFlows.var\"#36#38\"\n\n\nPartial derivative wrt time of a function.\n\nExample\n\njulia> ∂ₜ((t,x) -> t*x)(0,8)\n8\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.@Lie-Tuple{Expr, Any, Any}","page":"Developers","title":"CTFlows.@Lie","text":"Macros for Poisson brackets\n\nExample\n\njulia> H0 = (x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7]) autonomous=true variable=false\n#\njulia> H0 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7]) autonomous=false variable=false\n#\njulia> H0 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2) autonomous=true variable=true\n#\njulia> H0 = (t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7], 2) autonomous=false variable=true\n\n\n\n\n\n","category":"macro"},{"location":"dev.html#CTFlows.@Lie-Tuple{Expr, Any}","page":"Developers","title":"CTFlows.@Lie","text":"Macros for Lie and Poisson brackets\n\nExample\n\njulia> H0 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7]) autonomous=false\n#\njulia> H0 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2) variable=true\n#\n\n\n\n\n\n","category":"macro"},{"location":"dev.html#CTFlows.@Lie-Tuple{Expr}","page":"Developers","title":"CTFlows.@Lie","text":"Macros for Lie and Poisson brackets\n\nExample\n\njulia> F0 = VectorField(x -> [x[1], x[2], (1-x[3])])\njulia> F1 = VectorField(x -> [0, -x[3], x[2]])\njulia> @Lie [F0, F1]([1, 2, 3])\n[0, 5, 4]\n#\njulia> F0 = VectorField((t, x) -> [t+x[1], x[2], (1-x[3])], autonomous=false)\njulia> F1 = VectorField((t, x) -> [t, -x[3], x[2]], autonomous=false)\njulia> @Lie [F0, F1](1, [1, 2, 3])\n#\njulia> F0 = VectorField((x, v) -> [x[1]+v, x[2], (1-x[3])], variable=true)\njulia> F1 = VectorField((x, v) -> [0, -x[3]-v, x[2]], variable=true)\njulia> @Lie [F0, F1]([1, 2, 3], 2)\n#\njulia> F0 = VectorField((t, x, v) -> [t+x[1]+v, x[2], (1-x[3])], autonomous=false, variable=true)\njulia> F1 = VectorField((t, x, v) -> [t, -x[3]-v, x[2]], autonomous=false, variable=true)\njulia> @Lie [F0, F1](1, [1, 2, 3], 2)\n#\njulia> H0 = Hamiltonian((x, p) -> 0.5*(2x[1]^2+x[2]^2+p[1]^2))\njulia> H1 = Hamiltonian((x, p) -> 0.5*(3x[1]^2+x[2]^2+p[2]^2))\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7])\n3.0\n#\njulia> H0 = Hamiltonian((t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2), autonomous=false)\njulia> H1 = Hamiltonian((t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2), autonomous=false)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7])\n#\njulia> H0 = Hamiltonian((x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v), variable=true)\njulia> H1 = Hamiltonian((x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v), variable=true)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2)\n#\njulia> H0 = Hamiltonian((t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v), autonomous=false, variable=true)\njulia> H1 = Hamiltonian((t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v), autonomous=false, variable=true)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7], 2)\n#\n\n\n\n\n\n","category":"macro"},{"location":"dev.html","page":"Developers","title":"Developers","text":"","category":"page"},{"location":"index.html#CTFlows.jl","page":"Introduction","title":"CTFlows.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The CTFlows.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"flowchart TD\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/'>OptimalControl</a>) --> B(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctbase.html'>CTBase</a>)\nO --> D(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctdirect.html'>CTDirect</a>)\nO --> F(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctflows.html'>CTFlows</a>)\nF --> B\nD --> B\nstyle F fill:#FBF275","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"It aims to provide tools to solve mathematical flows of vector fields, and in particular Hamiltonian vector fields directly from the definition of the Hamiltonian, using automatic differentiation to construct the assiocated Hamiltonian vector field.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The flow is then computed thanks to OrdinaryDiffEq.jl package.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
