var documenterSearchIndex = {"docs":
[{"location":"api.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"CollapsedDocStrings = true","category":"page"},{"location":"api.html#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Pages   = [\"api.md\"]\nModules = [CTFlows]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api.html#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Modules = [CTFlows]\nOrder   = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api.html","page":"API","title":"API","text":"","category":"page"},{"location":"dev.html#Private-functions","page":"Developers","title":"Private functions","text":"","category":"section"},{"location":"dev.html","page":"Developers","title":"Developers","text":"CollapsedDocStrings = true","category":"page"},{"location":"dev.html#Index","page":"Developers","title":"Index","text":"","category":"section"},{"location":"dev.html","page":"Developers","title":"Developers","text":"Pages   = [\"dev.md\"]\nModules = [CTFlows]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev.html#Documentation","page":"Developers","title":"Documentation","text":"","category":"section"},{"location":"dev.html","page":"Developers","title":"Developers","text":"Modules = [CTFlows]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"dev.html#CTFlows.makeH-Tuple{CTBase.Dynamics, CTBase.ControlLaw, CTBase.Lagrange, Real, Real, CTBase.MixedConstraint, CTBase.Multiplier}","page":"Developers","title":"CTFlows.makeH","text":"makeH(\n    f::CTBase.Dynamics,\n    u::CTBase.ControlLaw,\n    f⁰::CTBase.Lagrange,\n    p⁰::Real,\n    s::Real,\n    g::CTBase.MixedConstraint,\n    μ::CTBase.Multiplier\n) -> CTFlows.var\"#H#42\"{CTBase.Dynamics{TF, TD, VD}, CTBase.ControlLaw{TF1, TD1, VD1}, CTBase.Lagrange{TF2, TD2, VD2}, var\"#s182\", var\"#s1821\", CTBase.MixedConstraint{TF3, TD3, VD3}, CTBase.Multiplier{TF4, TD4, VD4}} where {TF<:Function, TD<:CTBase.TimeDependence, VD<:CTBase.VariableDependence, TF1<:Function, TD1<:CTBase.TimeDependence, VD1<:CTBase.VariableDependence, TF2<:Function, TD2<:CTBase.TimeDependence, VD2<:CTBase.VariableDependence, var\"#s182\"<:Real, var\"#s1821\"<:Real, TF3<:Function, TD3<:CTBase.TimeDependence, VD3<:CTBase.VariableDependence, TF4<:Function, TD4<:CTBase.TimeDependence, VD4<:CTBase.VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + s p⁰ f⁰(t, x, u(t, x, p)) + μ(t, x, p) ⋅ g(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.makeH-Tuple{CTBase.Dynamics, CTBase.ControlLaw, CTBase.Lagrange, Real, Real}","page":"Developers","title":"CTFlows.makeH","text":"makeH(\n    f::CTBase.Dynamics,\n    u::CTBase.ControlLaw,\n    f⁰::CTBase.Lagrange,\n    p⁰::Real,\n    s::Real\n) -> CTFlows.var\"#H#40\"{CTBase.Dynamics{TF, TD, VD}, CTBase.ControlLaw{TF1, TD1, VD1}, CTBase.Lagrange{TF2, TD2, VD2}, <:Real, <:Real} where {TF<:Function, TD<:CTBase.TimeDependence, VD<:CTBase.VariableDependence, TF1<:Function, TD1<:CTBase.TimeDependence, VD1<:CTBase.VariableDependence, TF2<:Function, TD2<:CTBase.TimeDependence, VD2<:CTBase.VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + s p⁰ f⁰(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.makeH-Tuple{CTBase.Dynamics, CTBase.ControlLaw, CTBase.MixedConstraint, CTBase.Multiplier}","page":"Developers","title":"CTFlows.makeH","text":"makeH(\n    f::CTBase.Dynamics,\n    u::CTBase.ControlLaw,\n    g::CTBase.MixedConstraint,\n    μ::CTBase.Multiplier\n) -> CTFlows.var\"#H#41\"{CTBase.Dynamics{TF, TD, VD}, CTBase.ControlLaw{TF1, TD1, VD1}, CTBase.MixedConstraint{TF2, TD2, VD2}, CTBase.Multiplier{TF3, TD3, VD3}} where {TF<:Function, TD<:CTBase.TimeDependence, VD<:CTBase.VariableDependence, TF1<:Function, TD1<:CTBase.TimeDependence, VD1<:CTBase.VariableDependence, TF2<:Function, TD2<:CTBase.TimeDependence, VD2<:CTBase.VariableDependence, TF3<:Function, TD3<:CTBase.TimeDependence, VD3<:CTBase.VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + μ(t, x, p) ⋅ g(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTFlows.makeH-Tuple{CTBase.Dynamics, CTBase.ControlLaw}","page":"Developers","title":"CTFlows.makeH","text":"makeH(\n    f::CTBase.Dynamics,\n    u::CTBase.ControlLaw\n) -> CTFlows.var\"#38#39\"{CTBase.Dynamics{TF, TD, VD}, CTBase.ControlLaw{TF1, TD1, VD1}} where {TF<:Function, TD<:CTBase.TimeDependence, VD<:CTBase.VariableDependence, TF1<:Function, TD1<:CTBase.TimeDependence, VD1<:CTBase.VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p f(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev.html","page":"Developers","title":"Developers","text":"","category":"page"},{"location":"index.html#CTFlows.jl","page":"Introduction","title":"CTFlows.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CurrentModule =  CTFlows","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The CTFlows.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"flowchart TD\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/'>OptimalControl</a>) --> B(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctbase.html'>CTBase</a>)\nO --> D(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctdirect.html'>CTDirect</a>)\nO --> F(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctflows.html'>CTFlows</a>)\nF --> B\nD --> B\nstyle F fill:#FBF275","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"It aims to provide tools to solve mathematical flows of vector fields, and in particular Hamiltonian vector fields directly from the definition of the Hamiltonian, using automatic differentiation to construct the assiocated Hamiltonian vector field.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The flow is then computed thanks to OrdinaryDiffEq.jl package.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
