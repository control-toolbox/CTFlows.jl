"""
$(TYPEDSIGNATURES)

Construct a flow for an optimal control problem using a given control law.

This method builds the Hamiltonian system associated with the optimal control problem (`ocp`)
and integrates the corresponding state–costate dynamics using the specified control law `u`.

# Arguments

- `ocp::CTModels.Model`: An optimal control problem defined using `CTModels`.
- `u::CTFlows.ControlLaw`: A feedback control law generated by `ControlLaw(...)` or similar.
- `alg`: Integration algorithm (default inferred).
- `abstol`: Absolute tolerance for the ODE solver.
- `reltol`: Relative tolerance for the ODE solver.
- `saveat`: Time points at which to save the solution.
- `internalnorm`: Optional norm function used by the integrator.
- `kwargs_Flow`: Additional keyword arguments passed to the solver.

# Returns

A flow object `f` such that:

- `f(t0, x0, p0, tf)` integrates the state and costate from `t0` to `tf`.
- `f((t0, tf), x0, p0)` returns the full trajectory over the interval.

# Example

```julia-repl
julia> u = (x, p) -> p
julia> f = Flow(ocp, ControlLaw(u))
```
"""
function CTFlows.Flow(
    ocp::CTModels.Model,
    u::CTFlows.ControlLaw;
    alg=__alg(),
    abstol=__abstol(),
    reltol=__reltol(),
    saveat=__saveat(),
    internalnorm=__internalnorm(),
    kwargs_Flow...,
)
    h, u_ = __create_hamiltonian(ocp, u)
    return __ocp_Flow(ocp, h, u_, alg, abstol, reltol, saveat, internalnorm; kwargs_Flow...)
end

"""
$(TYPEDSIGNATURES)

Construct a flow for an optimal control problem using a control function in feedback form.

This method constructs the Hamiltonian and integrates the associated state–costate dynamics
using a raw function `u`. It automatically wraps `u` as a control law.

# Arguments

- `ocp::CTModels.Model`: The optimal control problem.
- `u::Function`: A feedback control function:
    - If `ocp` is autonomous: `u(x, p)`
    - If non-autonomous: `u(t, x, p)`
- `autonomous::Bool`: Whether the control law depends on time.
- `variable::Bool`: Whether the OCP involves variable time (e.g., free final time).
- `alg`, `abstol`, `reltol`, `saveat`, `internalnorm`: ODE solver parameters.
- `kwargs_Flow`: Additional options.

# Returns

A `Flow` object compatible with function call interfaces for state propagation.

# Example

```julia-repl
julia> u = (t, x, p) -> t + p
julia> f = Flow(ocp, u)
```
"""
function CTFlows.Flow(
    ocp::CTModels.Model,
    u::Function;
    autonomous::Bool=__autonomous(ocp),
    variable::Bool=__variable(ocp),
    alg=__alg(),
    abstol=__abstol(),
    reltol=__reltol(),
    saveat=__saveat(),
    internalnorm=__internalnorm(),
    kwargs_Flow...,
)
    h, u_ = __create_hamiltonian(ocp, u; autonomous=autonomous, variable=variable)
    return __ocp_Flow(ocp, h, u_, alg, abstol, reltol, saveat, internalnorm; kwargs_Flow...)
end

"""
$(TYPEDSIGNATURES)

Construct a flow for an optimal control problem with control and constraint multipliers in feedback form.

This variant constructs a Hamiltonian system incorporating both the control law and a multiplier law
(e.g., for enforcing state or mixed constraints). All inputs must be consistent in time dependence.

# Arguments

- `ocp::CTModels.Model`: The optimal control problem.
- `u::ControlLaw or FeedbackControl`: Feedback control.
- `g::StateConstraint or MixedConstraint`: Constraint function.
- `μ::Multiplier`: Multiplier function.
- `alg`, `abstol`, `reltol`, `saveat`, `internalnorm`: Solver settings.
- `kwargs_Flow`: Additional options.

# Returns

A `Flow` object that integrates the constrained Hamiltonian dynamics.

# Example

```julia-repl
julia> f = Flow(ocp, (x, p) -> p[1], (x, u) -> x[1] - 1, (x, p) -> x[1]+p[1])
```

For non-autonomous cases:

```julia-repl
julia> f = Flow(ocp, (t, x, p) -> t + p, (t, x, u) -> x - 1, (t, x, p) -> x+p)
```

!!! warning

    All input functions must match the autonomous/non-autonomous nature of the problem.
"""
function CTFlows.Flow(
    ocp::CTModels.Model,
    u::Union{CTFlows.ControlLaw{<:Function,T,V},CTFlows.FeedbackControl{<:Function,T,V}},
    g::Union{
        CTFlows.MixedConstraint{<:Function,T,V},CTFlows.StateConstraint{<:Function,T,V}
    },
    μ::Union{CTFlows.Multiplier{<:Function,T,V}};
    alg=__alg(),
    abstol=__abstol(),
    reltol=__reltol(),
    saveat=__saveat(),
    internalnorm=__internalnorm(),
    kwargs_Flow...,
) where {T,V}
    h, u_ = __create_hamiltonian(ocp, u, g, μ)
    return __ocp_Flow(ocp, h, u_, alg, abstol, reltol, saveat, internalnorm; kwargs_Flow...)
end

"""
$(TYPEDSIGNATURES)

Construct a flow from a raw feedback control, constraint, and multiplier.

This version is for defining flows directly from user functions without wrapping them into
`ControlLaw`, `Constraint`, or `Multiplier` types. Automatically wraps and adapts them based
on time dependence.

# Arguments

- `ocp::CTModels.Model`: The optimal control problem.
- `u::Function`: Control law.
- `g::Function`: Constraint.
- `μ::Function`: Multiplier.
- `autonomous::Bool`: Whether the system is autonomous.
- `variable::Bool`: Whether time is a free variable.
- `alg`, `abstol`, `reltol`, `saveat`, `internalnorm`: Solver parameters.
- `kwargs_Flow`: Additional options.

# Returns

A `Flow` object ready for trajectory integration.
"""
function CTFlows.Flow(
    ocp::CTModels.Model,
    u::Function,
    g::Function,
    μ::Function;
    autonomous::Bool=__autonomous(ocp),
    variable::Bool=__variable(ocp),
    alg=__alg(),
    abstol=__abstol(),
    reltol=__reltol(),
    saveat=__saveat(),
    internalnorm=__internalnorm(),
    kwargs_Flow...,
)
    h, u_ = __create_hamiltonian(ocp, u, g, μ; autonomous=autonomous, variable=variable)
    return __ocp_Flow(ocp, h, u_, alg, abstol, reltol, saveat, internalnorm; kwargs_Flow...)
end

"""
$(TYPEDSIGNATURES)

Internal helper: builds the `OptimalControlFlow` object from a Hamiltonian and control law.

This function assembles the RHS, constructs the integrator, and packages the flow object.

# Arguments

- `ocp`: The original optimal control problem.
- `h`: A Hamiltonian structure.
- `u`: A control law.
- `alg`, `abstol`, `reltol`, `saveat`, `internalnorm`: Integration parameters.
- `kwargs_Flow`: Additional parameters.

# Returns

An `OptimalControlFlow` object, callable as a function for integration.

!!! note

    This function is internal and intended for constructing flows behind the scenes.
"""
function __ocp_Flow(
    ocp::CTModels.Model,
    h::CTFlows.Hamiltonian,
    u::CTFlows.ControlLaw,
    alg,
    abstol,
    reltol,
    saveat,
    internalnorm;
    kwargs_Flow...,
)
    rhs! = rhs(h)
    f = hamiltonian_usage(alg, abstol, reltol, saveat, internalnorm; kwargs_Flow...)
    kwargs_Flow = (
        kwargs_Flow...,
        alg=alg,
        abstol=abstol,
        reltol=reltol,
        saveat=saveat,
        internalnorm=internalnorm,
    )
    return OptimalControlFlow(f, rhs!, u, ocp, kwargs_Flow)
end
