var documenterSearchIndex = {"docs":
[{"location":"types.html#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types.html#Index","page":"Types","title":"Index","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"Pages   = [\"types.md\"]\nModules = [CTFlows]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"types.html#Documentation","page":"Types","title":"Documentation","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"","category":"page"},{"location":"differential_geometry.html#Differential-Geometry","page":"Differential Geometry","title":"Differential Geometry","text":"","category":"section"},{"location":"differential_geometry.html#Index","page":"Differential Geometry","title":"Index","text":"","category":"section"},{"location":"differential_geometry.html","page":"Differential Geometry","title":"Differential Geometry","text":"Pages   = [\"differential_geometry.md\"]\nModules = [CTFlows]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"differential_geometry.html#Documentation","page":"Differential Geometry","title":"Documentation","text":"","category":"section"},{"location":"differential_geometry.html#CTFlows.:⅋-Union{Tuple{V}, Tuple{CTFlows.VectorField{<:Function, CTFlows.Autonomous, V}, CTFlows.VectorField{<:Function, CTFlows.Autonomous, V}}} where V<:CTFlows.VariableDependence","page":"Differential Geometry","title":"CTFlows.:⅋","text":"⅋(\n    X::CTFlows.VectorField{<:Function, CTFlows.Autonomous, V<:CTFlows.VariableDependence},\n    Y::CTFlows.VectorField{<:Function, CTFlows.Autonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\n\"Directional derivative\" of a vector field: internal and only used to compute efficiently the Lie bracket of two vector fields, autonomous case\n\nExample\n\njulia> X = VectorField(x -> [x[2], -x[1]])\njulia> Y = VectorField(x -> [x[1], x[2]])\njulia> CTBase.:(⅋)(X, Y)([1, 2])\n[2, -1]\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.:⅋-Union{Tuple{V}, Tuple{CTFlows.VectorField{<:Function, CTFlows.NonAutonomous, V}, CTFlows.VectorField{<:Function, CTFlows.NonAutonomous, V}}} where V<:CTFlows.VariableDependence","page":"Differential Geometry","title":"CTFlows.:⅋","text":"⅋(\n    X::CTFlows.VectorField{<:Function, CTFlows.NonAutonomous, V<:CTFlows.VariableDependence},\n    Y::CTFlows.VectorField{<:Function, CTFlows.NonAutonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\n\"Directional derivative\" of a vector field: internal and only used to compute efficiently the Lie bracket of two vector fields, nonautonomous case\n\nExample\n\njulia> X = VectorField((t, x, v) -> [t + v[1] + v[2] + x[2], -x[1]], NonFixed, NonAutonomous)\njulia> Y = VectorField((t, x, v) ->  [v[1] + v[2] + x[1], x[2]], NonFixed, NonAutonomous)\njulia> CTBase.:(⅋)(X, Y)(1, [1, 2], [2, 3])\n[8, -1]\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.:⋅-Tuple{CTFlows.VectorField{<:Function, CTFlows.Autonomous}, Function}","page":"Differential Geometry","title":"CTFlows.:⋅","text":"⋅(\n    X::CTFlows.VectorField{<:Function, CTFlows.Autonomous},\n    f::Function\n) -> CTFlows.var\"#27#29\"{CTFlows.VectorField{var\"#s2\", CTFlows.Autonomous, var\"#s1\"}, <:Function} where {var\"#s2\"<:Function, var\"#s1\"<:CTFlows.VariableDependence}\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in autonomous case\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (X⋅f)([1, 2])\n0\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.:⋅-Tuple{CTFlows.VectorField{<:Function, CTFlows.NonAutonomous}, Function}","page":"Differential Geometry","title":"CTFlows.:⋅","text":"⋅(\n    X::CTFlows.VectorField{<:Function, CTFlows.NonAutonomous},\n    f::Function\n) -> CTFlows.var\"#31#33\"{CTFlows.VectorField{var\"#s26\", CTFlows.NonAutonomous, var\"#s2\"}, <:Function} where {var\"#s26\"<:Function, var\"#s2\"<:CTFlows.VariableDependence}\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in nonautonomous case\n\nExample\n\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (X⋅f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.:⋅-Tuple{Function, Function}","page":"Differential Geometry","title":"CTFlows.:⋅","text":"⋅(\n    X::Function,\n    f::Function\n) -> CTFlows.var\"#27#29\"{CTFlows.VectorField{var\"#s182\", CTFlows.Autonomous, CTFlows.Fixed}, <:Function} where var\"#s182\"<:Function\n\n\nLie derivative of a scalar function along a function. In this case both functions will be considered autonomous and non-variable.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (φ⋅f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (φ⋅f)(1, [1, 2], [2, 1])\nMethodError\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Lie-Tuple{CTFlows.VectorField, Function}","page":"Differential Geometry","title":"CTFlows.Lie","text":"Lie(\n    X::CTFlows.VectorField,\n    f::Function\n) -> Union{CTFlows.var\"#27#29\"{CTFlows.VectorField{var\"#s2\", CTFlows.Autonomous, var\"#s1\"}, <:Function} where {var\"#s2\"<:Function, var\"#s1\"<:CTFlows.VariableDependence}, CTFlows.var\"#31#33\"{CTFlows.VectorField{var\"#s26\", CTFlows.NonAutonomous, var\"#s2\"}, <:Function} where {var\"#s26\"<:Function, var\"#s2\"<:CTFlows.VariableDependence}}\n\n\nLie derivative of a scalar function along a vector field.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(X,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(X, f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Lie-Tuple{Function, Function}","page":"Differential Geometry","title":"CTFlows.Lie","text":"Lie(\n    X::Function,\n    f::Function;\n    autonomous,\n    variable\n) -> Union{CTFlows.var\"#27#29\"{CTFlows.VectorField{var\"#s2\", CTFlows.Autonomous, var\"#s1\"}, <:Function} where {var\"#s2\"<:Function, var\"#s1\"<:CTFlows.VariableDependence}, CTFlows.var\"#31#33\"{CTFlows.VectorField{var\"#s26\", CTFlows.NonAutonomous, var\"#s2\"}, <:Function} where {var\"#s26\"<:Function, var\"#s2\"<:CTFlows.VariableDependence}}\n\n\nLie derivative of a scalar function along a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, autonomous=false, variable=true)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Lie-Union{Tuple{V}, Tuple{CTFlows.VectorField{<:Function, CTFlows.Autonomous, V}, CTFlows.VectorField{<:Function, CTFlows.Autonomous, V}}} where V<:CTFlows.VariableDependence","page":"Differential Geometry","title":"CTFlows.Lie","text":"Lie(\n    X::CTFlows.VectorField{<:Function, CTFlows.Autonomous, V<:CTFlows.VariableDependence},\n    Y::CTFlows.VectorField{<:Function, CTFlows.Autonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), autonomous case\n\nExample\n\njulia> f = x -> [x[2], 2x[1]]\njulia> g = x -> [3x[2], -x[1]]\njulia> X = VectorField(f)\njulia> Y = VectorField(g)\njulia> Lie(X, Y)([1, 2])\n[7, -14]\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Lie-Union{Tuple{V}, Tuple{CTFlows.VectorField{<:Function, CTFlows.NonAutonomous, V}, CTFlows.VectorField{<:Function, CTFlows.NonAutonomous, V}}} where V<:CTFlows.VariableDependence","page":"Differential Geometry","title":"CTFlows.Lie","text":"Lie(\n    X::CTFlows.VectorField{<:Function, CTFlows.NonAutonomous, V<:CTFlows.VariableDependence},\n    Y::CTFlows.VectorField{<:Function, CTFlows.NonAutonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), nonautonomous case\n\nExample\n\njulia> f = (t, x, v) -> [t + x[2] + v, -2x[1] - v]\njulia> g = (t, x, v) -> [t + 3x[2] + v, -x[1] - v]\njulia> X = VectorField(f, NonAutonomous, NonFixed)\njulia> Y = VectorField(g, NonAutonomous, NonFixed)\njulia> Lie(X, Y)(1, [1, 2], 1)\n[-7,12]\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Lift-Tuple{CTFlows.VectorField}","page":"Differential Geometry","title":"CTFlows.Lift","text":"Lift(\n    X::CTFlows.VectorField\n) -> CTFlows.HamiltonianLift{CTFlows.VectorField{TF, TD, VD}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\n\nReturn the HamiltonianLift of a VectorField.\n\nExample\n\njulia> HL = Lift(VectorField(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false))\njulia> HL([1, 0], [0, 1])\n0\njulia> HL = Lift(VectorField((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true))\njulia> HL(1, [1, 0], [0, 1], 1)\n1\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Lift-Tuple{Function}","page":"Differential Geometry","title":"CTFlows.Lift","text":"Lift(\n    X::Function;\n    autonomous,\n    variable\n) -> CTFlows.var\"#19#23\"{<:Function}\n\n\nReturn the Lift of a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Poisson-Tuple{Function, Function}","page":"Differential Geometry","title":"CTFlows.Poisson","text":"Poisson(\n    f::Function,\n    g::Function;\n    autonomous,\n    variable\n) -> CTFlows.Hamiltonian\n\n\nPoisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, autonomous=false, variable=true)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Poisson-Union{Tuple{VD}, Tuple{TD}, Tuple{CTFlows.AbstractHamiltonian{TD, VD}, Function}} where {TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}","page":"Differential Geometry","title":"CTFlows.Poisson","text":"Poisson(\n    f::CTFlows.AbstractHamiltonian{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence},\n    g::Function\n) -> CTFlows.Hamiltonian\n\n\nPoisson bracket of an Hamiltonian function (subtype of AbstractHamiltonian) and a function : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> Poisson(F, g)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Poisson-Union{Tuple{VD}, Tuple{TD}, Tuple{Function, CTFlows.AbstractHamiltonian{TD, VD}}} where {TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}","page":"Differential Geometry","title":"CTFlows.Poisson","text":"Poisson(\n    f::Function,\n    g::CTFlows.AbstractHamiltonian{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n) -> CTFlows.Hamiltonian\n\n\nPoisson bracket of a function and an Hamiltonian function (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> G = Hamiltonian(g)          \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(f, G)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Poisson-Union{Tuple{V}, Tuple{CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V}, CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V}}} where V<:CTFlows.VariableDependence","page":"Differential Geometry","title":"CTFlows.Poisson","text":"Poisson(\n    f::CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V<:CTFlows.VariableDependence},\n    g::CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> G = Hamiltonian(g)\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Poisson-Union{Tuple{V}, Tuple{CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V}, CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V}}} where V<:CTFlows.VariableDependence","page":"Differential Geometry","title":"CTFlows.Poisson","text":"Poisson(\n    f::CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V<:CTFlows.VariableDependence},\n    g::CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), non autonomous case\n\nExample\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n-76\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{CTFlows.HamiltonianLift{T, V}, CTFlows.HamiltonianLift{T, V}}} where {T<:CTFlows.TimeDependence, V<:CTFlows.VariableDependence}","page":"Differential Geometry","title":"CTFlows.Poisson","text":"Poisson(\n    f::CTFlows.HamiltonianLift{T<:CTFlows.TimeDependence, V<:CTFlows.VariableDependence},\n    g::CTFlows.HamiltonianLift{T<:CTFlows.TimeDependence, V<:CTFlows.VariableDependence}\n)\n\n\nPoisson bracket of two HamiltonianLift functions : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = x -> [x[1]^2+x[2]^2, 2x[1]^2]\njulia> g = x -> [3x[2]^2, x[2]-x[1]^2]\njulia> F = Lift(f)\njulia> G = Lift(g)\njulia> Poisson(F, G)([1, 2], [2, 1])\n-64\njulia> f = (t, x, v) -> [t*v[1]*x[2]^2, 2x[1]^2 + + v[2]]\njulia> g = (t, x, v) -> [3x[2]^2 + -x[1]^2, t - v[2]]\njulia> F = Lift(f, NonAutonomous, NonFixed)\njulia> G = Lift(g, NonAutonomous, NonFixed)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n100\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.∂ₜ-Tuple{Any}","page":"Differential Geometry","title":"CTFlows.∂ₜ","text":"∂ₜ(f) -> CTFlows.var\"#36#38\"\n\n\nPartial derivative wrt time of a function.\n\nExample\n\njulia> ∂ₜ((t,x) -> t*x)(0,8)\n8\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.@Lie-Tuple{Expr, Any, Any}","page":"Differential Geometry","title":"CTFlows.@Lie","text":"Macros for Poisson brackets\n\nExample\n\njulia> H0 = (x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7]) autonomous=true variable=false\n#\njulia> H0 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7]) autonomous=false variable=false\n#\njulia> H0 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2) autonomous=true variable=true\n#\njulia> H0 = (t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7], 2) autonomous=false variable=true\n\n\n\n\n\n","category":"macro"},{"location":"differential_geometry.html#CTFlows.@Lie-Tuple{Expr, Any}","page":"Differential Geometry","title":"CTFlows.@Lie","text":"Macros for Lie and Poisson brackets\n\nExample\n\njulia> H0 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7]) autonomous=false\n#\njulia> H0 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2) variable=true\n#\n\n\n\n\n\n","category":"macro"},{"location":"differential_geometry.html#CTFlows.@Lie-Tuple{Expr}","page":"Differential Geometry","title":"CTFlows.@Lie","text":"Macros for Lie and Poisson brackets\n\nExample\n\njulia> F0 = VectorField(x -> [x[1], x[2], (1-x[3])])\njulia> F1 = VectorField(x -> [0, -x[3], x[2]])\njulia> @Lie [F0, F1]([1, 2, 3])\n[0, 5, 4]\n#\njulia> F0 = VectorField((t, x) -> [t+x[1], x[2], (1-x[3])], autonomous=false)\njulia> F1 = VectorField((t, x) -> [t, -x[3], x[2]], autonomous=false)\njulia> @Lie [F0, F1](1, [1, 2, 3])\n#\njulia> F0 = VectorField((x, v) -> [x[1]+v, x[2], (1-x[3])], variable=true)\njulia> F1 = VectorField((x, v) -> [0, -x[3]-v, x[2]], variable=true)\njulia> @Lie [F0, F1]([1, 2, 3], 2)\n#\njulia> F0 = VectorField((t, x, v) -> [t+x[1]+v, x[2], (1-x[3])], autonomous=false, variable=true)\njulia> F1 = VectorField((t, x, v) -> [t, -x[3]-v, x[2]], autonomous=false, variable=true)\njulia> @Lie [F0, F1](1, [1, 2, 3], 2)\n#\njulia> H0 = Hamiltonian((x, p) -> 0.5*(2x[1]^2+x[2]^2+p[1]^2))\njulia> H1 = Hamiltonian((x, p) -> 0.5*(3x[1]^2+x[2]^2+p[2]^2))\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7])\n3.0\n#\njulia> H0 = Hamiltonian((t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2), autonomous=false)\njulia> H1 = Hamiltonian((t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2), autonomous=false)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7])\n#\njulia> H0 = Hamiltonian((x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v), variable=true)\njulia> H1 = Hamiltonian((x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v), variable=true)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2)\n#\njulia> H0 = Hamiltonian((t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v), autonomous=false, variable=true)\njulia> H1 = Hamiltonian((t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v), autonomous=false, variable=true)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7], 2)\n#\n\n\n\n\n\n","category":"macro"},{"location":"differential_geometry.html","page":"Differential Geometry","title":"Differential Geometry","text":"","category":"page"},{"location":"vector_field.html#Vector-Field","page":"Vector Field","title":"Vector Field","text":"","category":"section"},{"location":"vector_field.html#Index","page":"Vector Field","title":"Index","text":"","category":"section"},{"location":"vector_field.html","page":"Vector Field","title":"Vector Field","text":"Pages   = [\"vector_field.md\"]\nModules = [CTFlows, CTFlowsODE]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"vector_field.html#Documentation","page":"Vector Field","title":"Documentation","text":"","category":"section"},{"location":"vector_field.html#CTFlowsODE.vector_field_usage-NTuple{5, Any}","page":"Vector Field","title":"CTFlowsODE.vector_field_usage","text":"vector_field_usage(\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm;\n    kwargs_Flow...\n) -> Any\n\n\nReturns a function that solves ODE problem associated to classical vector field.\n\n\n\n\n\n","category":"method"},{"location":"vector_field.html","page":"Vector Field","title":"Vector Field","text":"","category":"page"},{"location":"default.html#Default","page":"Default","title":"Default","text":"","category":"section"},{"location":"default.html#Index","page":"Default","title":"Index","text":"","category":"section"},{"location":"default.html","page":"Default","title":"Default","text":"Pages   = [\"default.md\"]\nModules = [CTFlows]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"default.html#Documentation","page":"Default","title":"Documentation","text":"","category":"section"},{"location":"default.html","page":"Default","title":"Default","text":"","category":"page"},{"location":"optimal_control_problem.html#Optimal-Control-Problem","page":"Optimal Control Problem","title":"Optimal Control Problem","text":"","category":"section"},{"location":"optimal_control_problem.html#Index","page":"Optimal Control Problem","title":"Index","text":"","category":"section"},{"location":"optimal_control_problem.html","page":"Optimal Control Problem","title":"Optimal Control Problem","text":"Pages   = [\"optimal_control_problem.md\"]\nModules = [CTFlows, CTFlowsODE]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"optimal_control_problem.html#Documentation","page":"Optimal Control Problem","title":"Documentation","text":"","category":"section"},{"location":"optimal_control_problem.html#CTFlows.Flow-Tuple{CTModels.Model, CTFlows.ControlLaw}","page":"Optimal Control Problem","title":"CTFlows.Flow","text":"Flow(\n    ocp::CTModels.Model,\n    u_::CTFlows.ControlLaw;\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.OptimalControlFlow\n\n\nFlow from an optimal control problem and a control function in feedback form.\n\nExample\n\njulia> f = Flow(ocp, (x, p) -> p)\n\nwarning: Warning\nThe time dependence of the control function must be consistent with the time dependence of the optimal control problem. The dimension of the output of the control function must be consistent with the dimension usage of the control of the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem.html#CTFlows.Flow-Union{Tuple{V}, Tuple{T}, Tuple{CTModels.Model, Union{CTFlows.ControlLaw{<:Function, T, V}, CTFlows.FeedbackControl{<:Function, T, V}}, Union{CTFlows.MixedConstraint{<:Function, T, V}, CTFlows.StateConstraint{<:Function, T, V}}, CTFlows.Multiplier{<:Function, T, V}}} where {T, V}","page":"Optimal Control Problem","title":"CTFlows.Flow","text":"Flow(\n    ocp::CTModels.Model,\n    u_::Union{CTFlows.ControlLaw{<:Function, T, V}, CTFlows.FeedbackControl{<:Function, T, V}},\n    g_::Union{CTFlows.MixedConstraint{<:Function, T, V}, CTFlows.StateConstraint{<:Function, T, V}},\n    μ_::CTFlows.Multiplier{<:Function, T, V};\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.OptimalControlFlow\n\n\nFlow from an optimal control problem, a control function in feedback form, a state constraint and its  associated multiplier in feedback form.\n\nExample\n\njulia> ocp = Model(autonomous=false)\njulia> f = Flow(ocp, (t, x, p) -> p[1], (t, x, u) -> x[1] - 1, (t, x, p) -> x[1]+p[1])\n\nwarning: Warning\nThe time dependence of the control function must be consistent with the time dependence of the optimal control problem. The dimension of the output of the control function must be consistent with the dimension usage of the control of the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem.html","page":"Optimal Control Problem","title":"Optimal Control Problem","text":"","category":"page"},{"location":"ext_types.html#Extension-Types","page":"Extension Types","title":"Extension Types","text":"","category":"section"},{"location":"ext_types.html#Index","page":"Extension Types","title":"Index","text":"","category":"section"},{"location":"ext_types.html","page":"Extension Types","title":"Extension Types","text":"Pages   = [\"ext_types.md\"]\nModules = [CTFlows, CTFlowsODE, CTModels]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"ext_types.html#Documentation","page":"Extension Types","title":"Documentation","text":"","category":"section"},{"location":"ext_types.html#CTFlowsODE.OptimalControlFlowSolution","page":"Extension Types","title":"CTFlowsODE.OptimalControlFlowSolution","text":"struct OptimalControlFlowSolution\n\nType of an optimal control flow solution.\n\nFields\n\node_sol::Any\nfeedback_control::CTFlows.ControlLaw\nocp::CTModels.Model\nvariable::Union{Real, AbstractVector{<:Real}}\n\n\n\n\n\n","category":"type"},{"location":"ext_types.html#CTModels.Solution-Tuple{CTFlowsODE.OptimalControlFlowSolution}","page":"Extension Types","title":"CTModels.Solution","text":"Solution(\n    ocfs::CTFlowsODE.OptimalControlFlowSolution;\n    kwargs...\n) -> CTModels.Solution{TimeGridModelType, TimesModelType, StateModelType, ControlModelType, VariableModelType, CostateModelType, Float64, DualModelType, CTModels.SolverInfos{Dict{Symbol, Any}}, ModelType} where {TimeGridModelType<:CTModels.TimeGridModel, TimesModelType<:CTModels.TimesModel, StateModelType<:Union{CTModels.StateModelSolution{CTModels.var\"#114#136\"{CTFlowsODE.var\"#8#15\"{CTFlowsODE.var\"#x#11\"{CTFlowsODE.OptimalControlFlowSolution, Int64}}}}, CTModels.StateModelSolution{CTModels.var\"#115#137\"{CTFlowsODE.var\"#8#15\"{CTFlowsODE.var\"#x#11\"{CTFlowsODE.OptimalControlFlowSolution, Int64}}}}}, ControlModelType<:Union{CTModels.ControlModelSolution{CTModels.var\"#116#138\"{CTFlowsODE.var\"#9#16\"{CTFlowsODE.var\"#u#13\"{CTFlowsODE.OptimalControlFlowSolution, CTFlowsODE.var\"#p#12\"{CTFlowsODE.OptimalControlFlowSolution, Int64}, CTFlowsODE.var\"#x#11\"{CTFlowsODE.OptimalControlFlowSolution, Int64}}}}}, CTModels.ControlModelSolution{CTModels.var\"#117#139\"{CTFlowsODE.var\"#9#16\"{CTFlowsODE.var\"#u#13\"{CTFlowsODE.OptimalControlFlowSolution, CTFlowsODE.var\"#p#12\"{CTFlowsODE.OptimalControlFlowSolution, Int64}, CTFlowsODE.var\"#x#11\"{CTFlowsODE.OptimalControlFlowSolution, Int64}}}}}}, VariableModelType<:Union{CTModels.VariableModelSolution{Vector{Float64}}, CTModels.VariableModelSolution{Float64}}, CostateModelType<:Union{CTModels.var\"#118#140\"{CTFlowsODE.var\"#10#17\"{CTFlowsODE.var\"#p#12\"{CTFlowsODE.OptimalControlFlowSolution, Int64}}}, CTModels.var\"#119#141\"{CTFlowsODE.var\"#10#17\"{CTFlowsODE.var\"#p#12\"{CTFlowsODE.OptimalControlFlowSolution, Int64}}}}, DualModelType<:(CTModels.DualModel{PC_Dual, BC_Dual, SC_LB_Dual, SC_UB_Dual, CC_LB_Dual, CC_UB_Dual, VC_LB_Dual, VC_UB_Dual} where {PC_Dual<:Union{Nothing, CTModels.var\"#121#143\", CTModels.var\"#122#144\"}, BC_Dual<:Union{Nothing, Vector{Float64}}, SC_LB_Dual<:Union{Nothing, CTModels.var\"#124#146\", CTModels.var\"#125#147\"}, SC_UB_Dual<:Union{Nothing, CTModels.var\"#127#149\", CTModels.var\"#128#150\"}, CC_LB_Dual<:Union{Nothing, CTModels.var\"#130#152\", CTModels.var\"#131#153\"}, CC_UB_Dual<:Union{Nothing, CTModels.var\"#133#155\", CTModels.var\"#134#156\"}, VC_LB_Dual<:Union{Nothing, Vector{Float64}}, VC_UB_Dual<:Union{Nothing, Vector{Float64}}}), ModelType<:CTModels.Model}\n\n\nConstruct an OptimalControlSolution from an OptimalControlFlowSolution.\n\n\n\n\n\n","category":"method"},{"location":"ext_types.html","page":"Extension Types","title":"Extension Types","text":"","category":"page"},{"location":"utils.html#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"utils.html#Index","page":"Utils","title":"Index","text":"","category":"section"},{"location":"utils.html","page":"Utils","title":"Utils","text":"Pages   = [\"utils.md\"]\nModules = [CTFlows]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"utils.html#Documentation","page":"Utils","title":"Documentation","text":"","category":"section"},{"location":"utils.html#CTFlows.ctgradient","page":"Utils","title":"CTFlows.ctgradient","text":"ctgradient(f::Function, x::Real) -> Any\n\n\nCompute the derivative of a scalar function f at a scalar point x.\n\nArguments\n\nf::Function: A scalar-valued function.\nx::ctNumber: A scalar input.\n\nReturns\n\nThe derivative of f evaluated at x.\n\nExample\n\njulia> ctgradient(x -> x^2, 3.0)  # returns 6.0\n\n\n\n\n\nctgradient(f::Function, x) -> Any\n\n\nCompute the gradient of a scalar function f at a vector point x.\n\nArguments\n\nf::Function: A scalar-valued function accepting a vector input.\nx: A vector of numbers.\n\nReturns\n\nA vector representing the gradient ∇f(x).\n\nExample\n\njulia> ctgradient(x -> sum(x.^2), [1.0, 2.0])  # returns [2.0, 4.0]\n\n\n\n\n\nctgradient(X::CTFlows.VectorField, x) -> Any\n\n\nCompute the gradient of a VectorField at a given point.\n\nArguments\n\nX::VectorField: A vector field object with a callable function X.f.\nx: A scalar or vector input.\n\nReturns\n\nThe derivative or gradient depending on the type of x.\n\nExample\n\njulia> X = VectorField(x -> x^2)\njulia> ctgradient(X, 2.0)  # returns 4.0\n\n\n\n\n\n","category":"function"},{"location":"utils.html#CTFlows.ctjacobian","page":"Utils","title":"CTFlows.ctjacobian","text":"ctjacobian(f::Function, x::Real) -> Any\n\n\nCompute the Jacobian of a vector-valued function f at a scalar point x.\n\nArguments\n\nf::Function: A vector-valued function.\nx::ctNumber: A scalar input.\n\nReturns\n\nA matrix representing the Jacobian Jf(x).\n\nExample\n\njulia> f(x) = [sin(x), cos(x)]\njulia> ctjacobian(f, 0.0)  # returns a 2×1 matrix\n\n\n\n\n\nctjacobian(f::Function, x) -> Any\n\n\nCompute the Jacobian of a vector-valued function f at a vector point x.\n\nArguments\n\nf::Function: A vector-valued function.\nx: A vector input.\n\nReturns\n\nA matrix representing the Jacobian Jf(x).\n\nExample\n\njulia> f(x) = [x[1]^2, x[2]^2]\njulia> ctjacobian(f, [1.0, 2.0])  # returns [2.0 0.0; 0.0 4.0]\n\n\n\n\n\nctjacobian(X::CTFlows.VectorField, x) -> Any\n\n\nCompute the Jacobian of a VectorField at a given point.\n\nArguments\n\nX::VectorField: A vector field object with a callable function X.f.\nx: A scalar or vector input.\n\nReturns\n\nA matrix representing the Jacobian of X at x.\n\nExample\n\njulia> X = VectorField(x -> [x[1]^2, x[2]])\njulia> ctjacobian(X, [1.0, 3.0])  # returns [2.0 0.0; 0.0 1.0]\n\n\n\n\n\n","category":"function"},{"location":"utils.html","page":"Utils","title":"Utils","text":"","category":"page"},{"location":"optimal_control_problem_utils.html#Optimal-Control-Problem-Utils","page":"Optimal Control Problem Utils","title":"Optimal Control Problem Utils","text":"","category":"section"},{"location":"optimal_control_problem_utils.html#Index","page":"Optimal Control Problem Utils","title":"Index","text":"","category":"section"},{"location":"optimal_control_problem_utils.html","page":"Optimal Control Problem Utils","title":"Optimal Control Problem Utils","text":"Pages   = [\"optimal_control_problem_utils.md\"]\nModules = [CTFlows]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"optimal_control_problem_utils.html#Documentation","page":"Optimal Control Problem Utils","title":"Documentation","text":"","category":"section"},{"location":"optimal_control_problem_utils.html#CTFlows.makeH-Tuple{CTFlows.Dynamics, CTFlows.ControlLaw, CTFlows.Lagrange, Real, Real, CTFlows.MixedConstraint, CTFlows.Multiplier}","page":"Optimal Control Problem Utils","title":"CTFlows.makeH","text":"makeH(\n    f::CTFlows.Dynamics,\n    u::CTFlows.ControlLaw,\n    f⁰::CTFlows.Lagrange,\n    p⁰::Real,\n    s::Real,\n    g::CTFlows.MixedConstraint,\n    μ::CTFlows.Multiplier\n) -> CTFlows.var\"#H#102\"{CTFlows.Dynamics{TF, TD, VD}, CTFlows.ControlLaw{TF1, TD1, VD1}, CTFlows.Lagrange{TF2, TD2, VD2}, var\"#s182\", var\"#s1821\", CTFlows.MixedConstraint{TF3, TD3, VD3}, CTFlows.Multiplier{TF4, TD4, VD4}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence, TF1<:Function, TD1<:CTFlows.TimeDependence, VD1<:CTFlows.VariableDependence, TF2<:Function, TD2<:CTFlows.TimeDependence, VD2<:CTFlows.VariableDependence, var\"#s182\"<:Real, var\"#s1821\"<:Real, TF3<:Function, TD3<:CTFlows.TimeDependence, VD3<:CTFlows.VariableDependence, TF4<:Function, TD4<:CTFlows.TimeDependence, VD4<:CTFlows.VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + s p⁰ f⁰(t, x, u(t, x, p)) + μ(t, x, p) ⋅ g(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem_utils.html#CTFlows.makeH-Tuple{CTFlows.Dynamics, CTFlows.ControlLaw, CTFlows.Lagrange, Real, Real}","page":"Optimal Control Problem Utils","title":"CTFlows.makeH","text":"makeH(\n    f::CTFlows.Dynamics,\n    u::CTFlows.ControlLaw,\n    f⁰::CTFlows.Lagrange,\n    p⁰::Real,\n    s::Real\n) -> CTFlows.var\"#H#100\"{CTFlows.Dynamics{TF, TD, VD}, CTFlows.ControlLaw{TF1, TD1, VD1}, CTFlows.Lagrange{TF2, TD2, VD2}, <:Real, <:Real} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence, TF1<:Function, TD1<:CTFlows.TimeDependence, VD1<:CTFlows.VariableDependence, TF2<:Function, TD2<:CTFlows.TimeDependence, VD2<:CTFlows.VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + s p⁰ f⁰(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem_utils.html#CTFlows.makeH-Tuple{CTFlows.Dynamics, CTFlows.ControlLaw, CTFlows.MixedConstraint, CTFlows.Multiplier}","page":"Optimal Control Problem Utils","title":"CTFlows.makeH","text":"makeH(\n    f::CTFlows.Dynamics,\n    u::CTFlows.ControlLaw,\n    g::CTFlows.MixedConstraint,\n    μ::CTFlows.Multiplier\n) -> CTFlows.var\"#H#101\"{CTFlows.Dynamics{TF, TD, VD}, CTFlows.ControlLaw{TF1, TD1, VD1}, CTFlows.MixedConstraint{TF2, TD2, VD2}, CTFlows.Multiplier{TF3, TD3, VD3}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence, TF1<:Function, TD1<:CTFlows.TimeDependence, VD1<:CTFlows.VariableDependence, TF2<:Function, TD2<:CTFlows.TimeDependence, VD2<:CTFlows.VariableDependence, TF3<:Function, TD3<:CTFlows.TimeDependence, VD3<:CTFlows.VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + μ(t, x, p) ⋅ g(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem_utils.html#CTFlows.makeH-Tuple{CTFlows.Dynamics, CTFlows.ControlLaw}","page":"Optimal Control Problem Utils","title":"CTFlows.makeH","text":"makeH(\n    f::CTFlows.Dynamics,\n    u::CTFlows.ControlLaw\n) -> CTFlows.var\"#98#99\"{CTFlows.Dynamics{TF, TD, VD}, CTFlows.ControlLaw{TF1, TD1, VD1}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence, TF1<:Function, TD1<:CTFlows.TimeDependence, VD1<:CTFlows.VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p f(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem_utils.html","page":"Optimal Control Problem Utils","title":"Optimal Control Problem Utils","text":"","category":"page"},{"location":"concatenation.html#Concatenation","page":"Concatenation","title":"Concatenation","text":"","category":"section"},{"location":"concatenation.html#Index","page":"Concatenation","title":"Index","text":"","category":"section"},{"location":"concatenation.html","page":"Concatenation","title":"Concatenation","text":"Pages   = [\"concatenation.md\"]\nModules = [CTFlows, CTFlowsODE, Base]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"concatenation.html#Documentation","page":"Concatenation","title":"Documentation","text":"","category":"section"},{"location":"concatenation.html#Base.:*-Union{Tuple{TF}, Tuple{TF, Tuple{Real, Any, TF}}} where TF<:CTFlowsODE.AbstractFlow","page":"Concatenation","title":"Base.:*","text":"Shorthand for concatenate(F, g) when g is a tuple (t_switch, η_switch, G) including a jump.\n\nArguments\n\nF::AbstractFlow: The first flow.\ng::Tuple{ctNumber, Any, AbstractFlow}: Tuple with switching time, jump value, and second flow.\n\nReturns\n\nA flow with a jump at t_switch and a switch from F to G.\n\nExample\n\nF * (1.0, η, G)\n\n\n\n\n\n","category":"method"},{"location":"concatenation.html#Base.:*-Union{Tuple{TF}, Tuple{TF, Tuple{Real, TF}}} where TF<:CTFlowsODE.AbstractFlow","page":"Concatenation","title":"Base.:*","text":"Shorthand for concatenate(F, g) when g is a tuple (t_switch, G).\n\nArguments\n\nF::AbstractFlow: The first flow.\ng::Tuple{ctNumber, AbstractFlow}: Tuple containing the switching time and second flow.\n\nReturns\n\nA new flow that switches from F to G at t_switch.\n\nExample\n\nF * (1.0, G)\n\n\n\n\n\n","category":"method"},{"location":"concatenation.html#CTFlowsODE.__concat_feedback_control-Tuple{CTFlowsODE.AbstractFlow, CTFlowsODE.AbstractFlow, Real}","page":"Concatenation","title":"CTFlowsODE.__concat_feedback_control","text":"Concatenate feedback control laws of two optimal control flows.\n\nArguments\n\nF, G: OptimalControlFlow instances.\nt_switch::Time: Switching time.\n\nReturns\n\nA ControlLaw that dispatches to F or G depending on t.\n\nExample\n\nu = __concat_feedback_control(F, G, 2.0)\nu(1.5, x, u, v)  # from F\nu(2.5, x, u, v)  # from G\n\n\n\n\n\n","category":"method"},{"location":"concatenation.html#CTFlowsODE.__concat_jumps","page":"Concatenation","title":"CTFlowsODE.__concat_jumps","text":"Concatenate the jumps of two flows, with optional extra jump at t_switch.\n\nArguments\n\nF, G: Flows with jump events.\njump: Optional tuple (t_switch, η_switch) to insert.\n\nReturns\n\nCombined list of jumps.\n\nExample\n\n__concat_jumps(F, G)\n__concat_jumps(F, G, (1.0, η))\n\n\n\n\n\n","category":"function"},{"location":"concatenation.html#CTFlowsODE.__concat_rhs-Tuple{CTFlowsODE.ODEFlow, CTFlowsODE.ODEFlow, Real}","page":"Concatenation","title":"CTFlowsODE.__concat_rhs","text":"Concatenate ODE right-hand sides with a switch at t_switch.\n\nArguments\n\nF, G: ODEFlow instances.\nt_switch::Time: Time at which to switch between flows.\n\nReturns\n\nA function of the form (x, v, t) -> ....\n\nExample\n\nrhs = __concat_rhs(F, G, 0.5)\nrhs(x, v, 0.4)  # F.rhs\nrhs(x, v, 0.6)  # G.rhs\n\n\n\n\n\n","category":"method"},{"location":"concatenation.html#CTFlowsODE.__concat_rhs-Tuple{CTFlowsODE.VectorFieldFlow, CTFlowsODE.VectorFieldFlow, Real}","page":"Concatenation","title":"CTFlowsODE.__concat_rhs","text":"Concatenate vector field right-hand sides with time-based switching.\n\nArguments\n\nF, G: VectorFieldFlow instances.\nt_switch::Time: Switching time.\n\nReturns\n\nA function of the form (x, v, t) -> ....\n\nExample\n\nrhs = __concat_rhs(F, G, 2.0)\nrhs(x, v, 1.0)  # uses F.rhs\nrhs(x, v, 3.0)  # uses G.rhs\n\n\n\n\n\n","category":"method"},{"location":"concatenation.html#CTFlowsODE.__concat_rhs-Union{Tuple{U}, Tuple{D}, Tuple{CTFlowsODE.AbstractFlow{D, U}, CTFlowsODE.AbstractFlow{D, U}, Real}} where {D, U}","page":"Concatenation","title":"CTFlowsODE.__concat_rhs","text":"Concatenate the right-hand sides of two flows F and G, switching at time t_switch.\n\nArguments\n\nF, G: Two flows of the same type.\nt_switch::Time: The switching time.\n\nReturns\n\nA function rhs! that dispatches to F.rhs! before t_switch, and to G.rhs! after.\n\nExample\n\nrhs = __concat_rhs(F, G, 1.0)\nrhs!(du, u, p, 0.5)  # uses F.rhs!\nrhs!(du, u, p, 1.5)  # uses G.rhs!\n\n\n\n\n\n","category":"method"},{"location":"concatenation.html#CTFlowsODE.__concat_tstops-Tuple{CTFlowsODE.AbstractFlow, CTFlowsODE.AbstractFlow, Real}","page":"Concatenation","title":"CTFlowsODE.__concat_tstops","text":"Concatenate the tstops (discontinuity times) of two flows and add the switching time.\n\nArguments\n\nF, G: Flows with tstops vectors.\nt_switch::Time: Switching time to include.\n\nReturns\n\nA sorted vector of unique tstops.\n\nExample\n\n__concat_tstops(F, G, 1.0)\n\n\n\n\n\n","category":"method"},{"location":"concatenation.html#CTFlowsODE.concatenate-Union{Tuple{TF}, Tuple{TF, Tuple{Real, Any, TF}}} where TF<:CTFlowsODE.AbstractFlow","page":"Concatenation","title":"CTFlowsODE.concatenate","text":"Concatenate two AbstractFlows and insert a jump at the switching time.\n\nArguments\n\nF::AbstractFlow\ng::Tuple{ctNumber,Any,AbstractFlow}: (t_switch, η_switch, G)\n\nReturns\n\nA concatenated flow with the jump included.\n\nExample\n\nF * (1.0, η, G)\n\n\n\n\n\n","category":"method"},{"location":"concatenation.html#CTFlowsODE.concatenate-Union{Tuple{TF}, Tuple{TF, Tuple{Real, Any, TF}}} where TF<:CTFlowsODE.OptimalControlFlow","page":"Concatenation","title":"CTFlowsODE.concatenate","text":"Concatenate two OptimalControlFlows and a jump at switching time.\n\nArguments\n\nF::OptimalControlFlow\ng::Tuple{ctNumber,Any,OptimalControlFlow}\n\nReturns\n\nA combined flow with jump and control law switching.\n\nExample\n\nF * (1.0, η, G)\n\n\n\n\n\n","category":"method"},{"location":"concatenation.html#CTFlowsODE.concatenate-Union{Tuple{TF}, Tuple{TF, Tuple{Real, TF}}} where TF<:CTFlowsODE.AbstractFlow","page":"Concatenation","title":"CTFlowsODE.concatenate","text":"Concatenate two AbstractFlow instances with a prescribed switching time.\n\nArguments\n\nF::AbstractFlow: First flow.\ng::Tuple{ctNumber,AbstractFlow}: Switching time and second flow.\n\nReturns\n\nA new flow that transitions from F to G at t_switch.\n\nExample\n\nF * (1.0, G)\n\n\n\n\n\n","category":"method"},{"location":"concatenation.html#CTFlowsODE.concatenate-Union{Tuple{TF}, Tuple{TF, Tuple{Real, TF}}} where TF<:CTFlowsODE.OptimalControlFlow","page":"Concatenation","title":"CTFlowsODE.concatenate","text":"Concatenate two OptimalControlFlows at a switching time.\n\nArguments\n\nF::OptimalControlFlow\ng::Tuple{ctNumber,OptimalControlFlow}\n\nReturns\n\nA combined flow with switched dynamics and feedback control.\n\nExample\n\nF * (1.0, G)\n\n\n\n\n\n","category":"method"},{"location":"concatenation.html","page":"Concatenation","title":"Concatenation","text":"","category":"page"},{"location":"function.html#Function","page":"Function","title":"Function","text":"","category":"section"},{"location":"function.html#Index","page":"Function","title":"Index","text":"","category":"section"},{"location":"function.html","page":"Function","title":"Function","text":"Pages   = [\"function.md\"]\nModules = [CTFlows, CTFlowsODE]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"function.html#Documentation","page":"Function","title":"Documentation","text":"","category":"section"},{"location":"function.html#CTFlowsODE.ode_usage-NTuple{5, Any}","page":"Function","title":"CTFlowsODE.ode_usage","text":"ode_usage(\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm;\n    kwargs_Flow...\n) -> Any\n\n\nReturns a function that solves any ODE problem with OrdinaryDiffEq.\n\n\n\n\n\n","category":"method"},{"location":"function.html","page":"Function","title":"Function","text":"","category":"page"},{"location":"ctflows.html#CTFlows","page":"CTFlows","title":"CTFlows","text":"","category":"section"},{"location":"ctflows.html#Index","page":"CTFlows","title":"Index","text":"","category":"section"},{"location":"ctflows.html","page":"CTFlows","title":"CTFlows","text":"Pages   = [\"ctflow.md\"]\nModules = [CTFlows]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"ctflows.html#Documentation","page":"CTFlows","title":"Documentation","text":"","category":"section"},{"location":"ctflows.html","page":"CTFlows","title":"CTFlows","text":"","category":"page"},{"location":"hamiltonian.html#Hamiltonian","page":"Hamiltonian","title":"Hamiltonian","text":"","category":"section"},{"location":"hamiltonian.html#Index","page":"Hamiltonian","title":"Index","text":"","category":"section"},{"location":"hamiltonian.html","page":"Hamiltonian","title":"Hamiltonian","text":"Pages   = [\"hamiltonian.md\"]\nModules = [CTFlows, CTFlowsODE]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"hamiltonian.html#Documentation","page":"Hamiltonian","title":"Documentation","text":"","category":"section"},{"location":"hamiltonian.html#CTFlowsODE.hamiltonian_usage-NTuple{5, Any}","page":"Hamiltonian","title":"CTFlowsODE.hamiltonian_usage","text":"hamiltonian_usage(\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm;\n    kwargs_Flow...\n) -> Any\n\n\nReturns a function that solves ODE problem associated to Hamiltonian vector field.\n\n\n\n\n\n","category":"method"},{"location":"hamiltonian.html#CTFlowsODE.rhs-Tuple{CTFlows.AbstractHamiltonian}","page":"Hamiltonian","title":"CTFlowsODE.rhs","text":"rhs(\n    h::CTFlows.AbstractHamiltonian\n) -> CTFlowsODE.var\"#rhs!#43\"{<:CTFlows.AbstractHamiltonian{TD, VD}} where {TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\n\nThe right and side from a Hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"hamiltonian.html","page":"Hamiltonian","title":"Hamiltonian","text":"","category":"page"},{"location":"ext_utils.html#Extension-Utils","page":"Extension Utils","title":"Extension Utils","text":"","category":"section"},{"location":"ext_utils.html#Index","page":"Extension Utils","title":"Index","text":"","category":"section"},{"location":"ext_utils.html","page":"Extension Utils","title":"Extension Utils","text":"Pages   = [\"ext_utils.md\"]\nModules = [CTFlows, CTFlowsODE]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"ext_utils.html#Documentation","page":"Extension Utils","title":"Documentation","text":"","category":"section"},{"location":"ext_utils.html","page":"Extension Utils","title":"Extension Utils","text":"","category":"page"},{"location":"index.html#CTFlows.jl","page":"Introduction","title":"CTFlows.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The CTFlows.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The root package is OptimalControl.jl which aims to provide tools to model and solve optimal control problems with ordinary differential equations by direct and indirect methods.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"API Documentation","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Pages = Main.API_PAGES\nDepth = 1","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"ext_default.html#Extension-Default","page":"Extension Default","title":"Extension Default","text":"","category":"section"},{"location":"ext_default.html#Index","page":"Extension Default","title":"Index","text":"","category":"section"},{"location":"ext_default.html","page":"Extension Default","title":"Extension Default","text":"Pages   = [\"ext_default.md\"]\nModules = [CTFlows, CTFlowsODE]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"ext_default.html#Documentation","page":"Extension Default","title":"Documentation","text":"","category":"section"},{"location":"ext_default.html#CTFlowsODE.__abstol-Tuple{}","page":"Extension Default","title":"CTFlowsODE.__abstol","text":"__abstol() -> Float64\n\n\nDefault absolute tolerance for ODE solvers.\n\nSee abstol from DifferentialEquations.\n\n\n\n\n\n","category":"method"},{"location":"ext_default.html#CTFlowsODE.__alg-Tuple{}","page":"Extension Default","title":"CTFlowsODE.__alg","text":"__alg(\n\n) -> Tsit5{typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!), Static.False}\n\n\nDefault algorithm for ODE solvers.\n\nSee alg from DifferentialEquations.\n\n\n\n\n\n","category":"method"},{"location":"ext_default.html#CTFlowsODE.__callback-Tuple{}","page":"Extension Default","title":"CTFlowsODE.__callback","text":"__callback()\n\n\nSee callback from DifferentialEquations.\n\n\n\n\n\n","category":"method"},{"location":"ext_default.html#CTFlowsODE.__internalnorm-Tuple{}","page":"Extension Default","title":"CTFlowsODE.__internalnorm","text":"__internalnorm() -> CTFlowsODE.var\"#1#2\"\n\n\nDefault internal norm.\n\n\n\n\n\n","category":"method"},{"location":"ext_default.html#CTFlowsODE.__reltol-Tuple{}","page":"Extension Default","title":"CTFlowsODE.__reltol","text":"__reltol() -> Float64\n\n\nDefault relative tolerance for ODE solvers.\n\nSee reltol from DifferentialEquations.\n\n\n\n\n\n","category":"method"},{"location":"ext_default.html#CTFlowsODE.__saveat-Tuple{}","page":"Extension Default","title":"CTFlowsODE.__saveat","text":"__saveat() -> Vector{Any}\n\n\nSee saveat from DifferentialEquations.\n\n\n\n\n\n","category":"method"},{"location":"ext_default.html#CTFlowsODE.__thevariable-NTuple{5, Any}","page":"Extension Default","title":"CTFlowsODE.__thevariable","text":"__thevariable(t0, x0, p0, tf, ocp) -> Any\n\n\nDefault variable from ocp.\n\n\n\n\n\n","category":"method"},{"location":"ext_default.html#CTFlowsODE.__thevariable-Tuple{Any, Any}","page":"Extension Default","title":"CTFlowsODE.__thevariable","text":"__thevariable(x0, p0) -> Vector\n\n\nDefault variable x0, p0.\n\n\n\n\n\n","category":"method"},{"location":"ext_default.html#CTFlowsODE.__thevariable-Tuple{Any}","page":"Extension Default","title":"CTFlowsODE.__thevariable","text":"__thevariable(x0) -> Vector\n\n\nDefault variable from x0.\n\n\n\n\n\n","category":"method"},{"location":"ext_default.html#CTFlowsODE.__tstops-Tuple{}","page":"Extension Default","title":"CTFlowsODE.__tstops","text":"__tstops() -> Vector{Real}\n\n\nSee tstops from DifferentialEquations.\n\n\n\n\n\n","category":"method"},{"location":"ext_default.html","page":"Extension Default","title":"Extension Default","text":"","category":"page"},{"location":"ctflowsode.html#CTFlowsODE","page":"CTFlowsODE","title":"CTFlowsODE","text":"","category":"section"},{"location":"ctflowsode.html#Index","page":"CTFlowsODE","title":"Index","text":"","category":"section"},{"location":"ctflowsode.html","page":"CTFlowsODE","title":"CTFlowsODE","text":"Pages   = [\"ctflowsode.md\"]\nModules = [CTFlows, CTFlowsODE]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"ctflowsode.html#Documentation","page":"CTFlowsODE","title":"Documentation","text":"","category":"section"},{"location":"ctflowsode.html#CTFlowsODE.CoTangent","page":"CTFlowsODE","title":"CTFlowsODE.CoTangent","text":"Alias for CTFlows.ctVector, representing cotangent vectors in continuous-time systems.\n\nUsed for denoting adjoint states or costates in optimal control formulations.\n\n\n\n\n\n","category":"type"},{"location":"ctflowsode.html#CTFlowsODE.DCoTangent","page":"CTFlowsODE","title":"CTFlowsODE.DCoTangent","text":"Alias for CTFlows.ctVector, representing derivative cotangent vectors.\n\nUseful in contexts where second-order information or directional derivatives of costates are required.\n\n\n\n\n\n","category":"type"},{"location":"ctflowsode.html#CTFlowsODE.AbstractFlow","page":"CTFlowsODE","title":"CTFlowsODE.AbstractFlow","text":"Abstract supertype for continuous-time flows.\n\nAbstractFlow{D,U} defines the interface for any flow system with:\n\nD: the type of the differential (typically a vector or matrix),\nU: the type of the state variable.\n\nSubtypes should define at least a right-hand side function for the system's dynamics.\n\n\n\n\n\n","category":"type"},{"location":"ctflowsode.html#CTFlowsODE.__autonomous","page":"CTFlowsODE","title":"CTFlowsODE.__autonomous","text":"Alias for CTFlows.__autonomous, a tag indicating that a flow is autonomous.\n\nUsed internally to specify behavior in constructors or when composing flows.\n\n\n\n\n\n","category":"function"},{"location":"ctflowsode.html#CTFlowsODE.__create_hamiltonian","page":"CTFlowsODE","title":"CTFlowsODE.__create_hamiltonian","text":"Alias for CTFlows.__create_hamiltonian.\n\nConstructs the Hamiltonian function for a given continuous-time optimal control problem. This internal function typically takes an objective, dynamics, and control constraints.\n\n\n\n\n\n","category":"function"},{"location":"ctflowsode.html#CTFlowsODE.__variable","page":"CTFlowsODE","title":"CTFlowsODE.__variable","text":"Alias for CTFlows.__variable, a tag indicating that a flow depends on external variables or is non-autonomous.\n\nUsed to distinguish time-dependent systems or flows with control/state parameterization.\n\n\n\n\n\n","category":"function"},{"location":"ctflowsode.html#CTFlowsODE.ctgradient","page":"CTFlowsODE","title":"CTFlowsODE.ctgradient","text":"Alias for CTFlows.ctgradient, a method to compute the gradient of a scalar function with respect to a state.\n\nIt dispatches appropriately depending on whether the input is a scalar or a vector, and uses ForwardDiff.jl.\n\n\n\n\n\n","category":"function"},{"location":"ctflowsode.html#CTFlowsODE.rg-Tuple{Int64, Int64}","page":"CTFlowsODE","title":"CTFlowsODE.rg","text":"Creates a range i:j, unless i == j, in which case returns i as an integer.\n\nUseful when indexing or slicing arrays with optional single-element flexibility.\n\n\n\n\n\n","category":"method"},{"location":"ctflowsode.html","page":"CTFlowsODE","title":"CTFlowsODE","text":"","category":"page"}]
}
