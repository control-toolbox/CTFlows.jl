# Differential Geometry Tools

CTFlows provides a comprehensive set of tools for differential geometry operations commonly used in control theory. This guide explains the mathematical concepts and their usage with practical examples.

## Overview

The differential geometry module provides:
- **Lie derivatives** and **Lie brackets** for vector fields
- **Poisson brackets** for Hamiltonian functions
- **Hamiltonian lifts** of vector fields
- A convenient **`@Lie` macro** for mathematical notation

All functions work with pure Julia functions (no wrappers required in V3).

---

## The `ad()` Function

The `ad()` function is the core operator that computes **directional derivatives**. Its behavior depends on what you apply it to:

### Case 1: Lie Derivative (Scalar Function)

When applied to a **scalar function** ``f : \mathbb{R}^n \to \mathbb{R}``, `ad(X, f)` computes the **Lie derivative**:

```math
\mathcal{L}_X f(x) = \nabla f(x)^\top \cdot X(x)
```

**Mathematical Interpretation**: The rate of change of ``f`` along the flow of the vector field ``X``.

**Example**:
```julia
using CTFlows

# Vector field
X(x) = [x[2], -x[1]]

# Scalar function
f(x) = x[1]^2 + x[2]^2

# Lie derivative
Lf = CTFlows.ad(X, f)

# Evaluate at a point
Lf([1.0, 2.0])  # Returns 0.0
```

**Explanation**: For a circular vector field ``X`` and radial function ``f(x) = \|x\|^2``, the Lie derivative is zero because ``X`` is tangent to level sets of ``f``.

---

### Case 2: Lie Bracket (Vector Field)

When applied to a **vector field** ``Y : \mathbb{R}^n \to \mathbb{R}^n``, `ad(X, Y)` computes the **Lie bracket**:

```math
[X, Y](x) = J_Y(x) \cdot X(x) - J_X(x) \cdot Y(x)
```

where ``J_X`` denotes the Jacobian matrix of ``X``.

**Mathematical Interpretation**: Measures the non-commutativity of the flows generated by ``X`` and ``Y``.

**Example**:
```julia
using CTFlows

# First vector field
X(x) = [x[2], 0.0]

# Second vector field  
Y(x) = [0.0, x[1]]

# Lie bracket
Z = CTFlows.ad(X, Y)

# Evaluate
Z([1.0, 2.0])  # Returns [-1.0, 2.0]
```

**Verification**: 
- ``J_Y = \begin{bmatrix} 0 & 0 \\ 1 & 0 \end{bmatrix}``, so ``J_Y \cdot X = \begin{bmatrix} 0 \\ x_2 \end{bmatrix}``
- ``J_X = \begin{bmatrix} 0 & 1 \\ 0 & 0 \end{bmatrix}``, so ``J_X \cdot Y = \begin{bmatrix} x_1 \\ 0 \end{bmatrix}``
- ``[X, Y] = \begin{bmatrix} -x_1 \\ x_2 \end{bmatrix}``

---

## The `@Lie` Macro

The `@Lie` macro provides **mathematical notation** for brackets:

### Lie Bracket Syntax

```julia
# These are equivalent:
Z = CTFlows.ad(X, Y)
Z = CTFlows.@Lie [X, Y]
```

**Example - Nested Brackets**:
```julia
using CTFlows

X(x) = [x[2], -x[1]]
Y(x) = [x[1], 0.0]

# Jacobi identity: [[X, Y], X] + [[Y, X], Y] = 0 (modulo cyclic permutation)
XY = CTFlows.@Lie [X, Y]
result = CTFlows.@Lie [XY, X]
```

### Poisson Bracket Syntax

```julia
# These are equivalent:
PB = CTFlows.Poisson(H, G)
PB = CTFlows.@Lie {H, G}
```

---

## Poisson Brackets

For Hamiltonian functions ``H, G : \mathbb{R}^n \times \mathbb{R}^n \to \mathbb{R}`` (with phase space coordinates ``(x, p)``), the **Poisson bracket** is:

```math
\{H, G\}(x, p) = \nabla_p H(x,p)^\top \cdot \nabla_x G(x,p) - \nabla_x H(x,p)^\top \cdot \nabla_p G(x,p)
```

**Mathematical Properties**:

1. **Antisymmetry**: ``\{H, G\} = -\{G, H\}``
2. **Bilinearity**: ``\{\alpha H_1 + \beta H_2, G\} = \alpha \{H_1, G\} + \beta \{H_2, G\}``
3. **Leibniz rule**: ``\{H, GK\} = \{H, G\}K + G\{H, K\}``
4. **Jacobi identity**: ``\{H, \{G, K\}\} + \{G, \{K, H\}\} + \{K, \{H, G\}\} = 0``

**Example**:
```julia
using CTFlows

# Kinetic energy
H(x, p) = 0.5 * (p[1]^2 + p[2]^2)

# Position coordinate
G(x, p) = x[1]

# Poisson bracket
PB = CTFlows.@Lie {H, G}

# Evaluate
PB([1.0, 2.0], [3.0, 4.0])  # Returns 3.0
```

**Interpretation**: ``\{H, x_i\} = \frac{\partial H}{\partial p_i}`` (Hamilton's equation for position).

---

## Hamiltonian Lift

The **Hamiltonian lift** of a vector field ``F : \mathbb{R}^n \to \mathbb{R}^n`` is the function:

```math
H_F(x, p) = p^\top \cdot F(x)
```

This extends a vector field on configuration space to a scalar function on phase space.

**Example**:
```julia
using CTFlows

# Vector field
F(x) = [x[1]^2, x[2]]

# Hamiltonian lift
H_F = CTFlows.Lift(F)

# Evaluate
H_F([1.0, 2.0], [0.5, 0.5])  # Returns 0.5*1 + 0.5*2 = 1.5
```

---

## Fundamental Theorem: Poisson Bracket of Lifts

A key relationship connects Poisson brackets of lifted Hamiltonians to Lie brackets of vector fields:

```math
\{H_F, H_G\}(x, p) = p^\top \cdot [F, G](x)
```

where ``H_F`` and ``H_G`` are the Hamiltonian lifts of ``F`` and ``G``.

**Proof Sketch**:
```math
\begin{aligned}
\{H_F, H_G\}(x,p) &= \nabla_p H_F \cdot \nabla_x H_G - \nabla_x H_F \cdot \nabla_p H_G \\
&= F(x)^\top \cdot (J_G(x)^\top p) - (J_F(x)^\top p)^\top \cdot G(x) \\
&= p^\top \cdot J_G(x) \cdot F(x) - p^\top \cdot J_F(x) \cdot G(x) \\
&= p^\top \cdot [F, G](x)
\end{aligned}
```

**Example - Verification**:
```julia
using CTFlows

# Two vector fields
F(x) = [x[2], 0.0]
G(x) = [0.0, x[1]]

# Method 1: Direct Lie bracket then dot product
LB = CTFlows.@Lie [F, G]
x, p = [1.0, 2.0], [3.0, 4.0]
result1 = p' * LB(x)

# Method 2: Poisson bracket of lifts
H_F = CTFlows.Lift(F)
H_G = CTFlows.Lift(G)
PB = CTFlows.@Lie {H_F, H_G}
result2 = PB(x, p)

# They are equal!
@assert result1 ≈ result2
```

---

## Time Derivative Operator

The `∂ₜ` function computes partial derivatives with respect to time:

```julia
using CTFlows

# Time-dependent function
f(t, x) = t^2 * x[1]

# Time derivative
∂f∂t = CTFlows.∂ₜ(f)

# Evaluate
∂f∂t(3.0, [2.0])  # Returns 2*3*2 = 12.0
```

---

## Advanced: Type Dispatch

For performance, you can use **type-based dispatch** when time/variable dependence is known at compile time:

```julia
using CTFlows

X(x) = [x[2], -x[1]]
f(x) = x[1]^2

# Type-based dispatch (faster)
Lf = CTFlows.ad(X, f, CTFlows.Autonomous, CTFlows.Fixed)
```

Time dependence types:
- `Autonomous`: Functions don't depend on time ``t``
- `NonAutonomous`: Functions depend on time ``t``

Variable dependence types:
- `Fixed`: No extra variables
- `NonFixed`: Depend on extra variables ``v``

---

## Complete Example: Optimal Control

Here's how these tools work together in an optimal control context:

```julia
using CTFlows

# Control system: ẋ = F(x) + u·G(x)
F(x) = [x[2], -x[1]]  # Drift
G(x) = [0.0, 1.0]     # Control direction

# Cost Hamiltonian
H₀(x) = 0.5 * (x[1]^2 + x[2]^2)

# Lifted Hamiltonians
H_F = CTFlows.Lift(F)
H_G = CTFlows.Lift(G)

# Maximum Principle: H = H₀ + H_F + u·H_G
# Optimal control: u* = -∂H/∂H_G if unconstrained

# Check integrability: {H_F, H_G} should determine system structure
integrability = CTFlows.@Lie {H_F, H_G}

# Evaluate integrability condition
x, p = [1.0, 0.0], [0.0, 1.0]
integrability(x, p)  # Related to [F, G]
```

---

## Summary Table

| Operation | Mathematical | CTFlows Syntax | Use Case |
|-----------|-------------|----------------|----------|
| Lie derivative | ``\mathcal{L}_X f`` | `ad(X, f)` | Rate of change along flow |
| Lie bracket | ``[X, Y]`` | `ad(X, Y)` or `@Lie [X, Y]` | Vector field commutator |
| Poisson bracket | ``\{H, G\}`` | `Poisson(H, G)` or `@Lie {H, G}` | Hamiltonian structure |
| Hamiltonian lift | ``H_F(x,p) = p \cdot F(x)`` | `Lift(F)` | Configuration → Phase space |
| Time derivative | ``\partial_t f`` | `∂ₜ(f)` | Time-dependent functions |

---

## Key Takeaways

1. **`ad(X, ·)` is context-aware**: 
   - Applied to scalar → Lie derivative
   - Applied to vector → Lie bracket

2. **`@Lie` macro provides mathematical notation**:
   - `[X, Y]` for Lie brackets
   - `{H, G}` for Poisson brackets

3. **Lifts connect geometry and Hamiltonian mechanics**:
   - ``\{H_F, H_G\} = p \cdot [F, G]``

4. **All operations use pure functions** (no wrappers in V3)

5. **Type dispatch available** for performance optimization

---

## References

For more mathematical background, see:
- Abraham & Marsden, *Foundations of Mechanics*
- Sussmann, "Lie brackets and control theory"
- Pontryagin et al., *The Mathematical Theory of Optimal Processes*

For detailed API documentation, see the [API Reference](@ref differential_geometry.md).
