var documenterSearchIndex = {"docs":
[{"location":"api.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"CurrentModule = CTFlows ","category":"page"},{"location":"api.html","page":"API","title":"API","text":"Modules = [CTFlows]\nOrder = [:module, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api.html#CTFlows.Flow-Union{Tuple{V}, Tuple{T}, Tuple{CTBase.OptimalControlModel{T, V}, Union{CTBase.ControlLaw{T, V}, CTBase.FeedbackControl{T, V}, Function}, Union{CTBase.MixedConstraint{T, V}, CTBase.StateConstraint{T, V}, Function}, Union{CTBase.Multiplier{T, V}, Function}}} where {T, V}","page":"API","title":"CTFlows.Flow","text":"Flow(\n    ocp::CTBase.OptimalControlModel{T, V},\n    u_::Union{CTBase.ControlLaw{T, V}, CTBase.FeedbackControl{T, V}, Function},\n    g_::Union{CTBase.MixedConstraint{T, V}, CTBase.StateConstraint{T, V}, Function},\n    μ_::Union{CTBase.Multiplier{T, V}, Function};\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    kwargs_Flow...\n) -> CTFlows.OptimalControlFlow\n\n\nFlow from an optimal control problem, a control function in feedback form, a state constraint and its  associated multiplier in feedback form.\n\nExample\n\njulia> ocp = Model(autonomous=false)\njulia> f = Flow(ocp, (t, x, p) -> p[1], (t, x, u) -> x[1] - 1, (t, x, p) -> x[1]+p[1])\n\nwarning: Warning\nThe time dependence of the control function must be consistent with the time dependence of the optimal control problem. The dimension of the output of the control function must be consistent with the dimension usage of the control of the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTFlows.Flow-Union{Tuple{V}, Tuple{T}, Tuple{CTBase.OptimalControlModel{T, V}, Union{CTBase.ControlLaw{T, V}, Function}}} where {T, V}","page":"API","title":"CTFlows.Flow","text":"Flow(\n    ocp::CTBase.OptimalControlModel{T, V},\n    u_::Union{CTBase.ControlLaw{T, V}, Function};\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    kwargs_Flow...\n) -> CTFlows.OptimalControlFlow\n\n\nFlow from an optimal control problem and a control function in feedback form.\n\nExample\n\njulia> f = Flow(ocp, (x, p) -> p)\n\nwarning: Warning\nThe time dependence of the control function must be consistent with the time dependence of the optimal control problem. The dimension of the output of the control function must be consistent with the dimension usage of the control of the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#Internal-functions","page":"Developers","title":"Internal functions","text":"","category":"section"},{"location":"dev-api.html","page":"Developers","title":"Developers","text":"CurrentModule = CTFlows ","category":"page"},{"location":"dev-api.html","page":"Developers","title":"Developers","text":"Modules = [CTFlows]\nOrder = [:module, :type, :function, :macro]\nPublic = false","category":"page"},{"location":"dev-api.html#CTBase.OptimalControlSolution-Tuple{CTFlows.OptimalControlFlowSolution}","page":"Developers","title":"CTBase.OptimalControlSolution","text":"OptimalControlSolution(\n    ocfs::CTFlows.OptimalControlFlowSolution\n) -> CTBase.OptimalControlSolution\n\n\nConstruct an OptimalControlSolution from an OptimalControlFlowSolution.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTFlows.OptimalControlFlowSolution","page":"Developers","title":"CTFlows.OptimalControlFlowSolution","text":"struct OptimalControlFlowSolution\n\nType of an optimal control flow solution.\n\nFields\n\node_sol::Any\nfeedback_control::CTBase.ControlLaw\nocp::CTBase.OptimalControlModel\nvariable::Union{Real, AbstractVector{<:Real}}\n\n\n\n\n\n","category":"type"},{"location":"dev-api.html#CTFlows.__abstol-Tuple{}","page":"Developers","title":"CTFlows.__abstol","text":"__abstol() -> Float64\n\n\nDefault absolute tolerance for ODE solvers.\n\nSee abstol from OrdinaryDiffEq.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTFlows.__alg-Tuple{}","page":"Developers","title":"CTFlows.__alg","text":"__alg(\n\n) -> OrdinaryDiffEq.Tsit5{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}\n\n\nDefault algorithm for ODE solvers.\n\nSee alg from OrdinaryDiffEq.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTFlows.__callback-Tuple{}","page":"Developers","title":"CTFlows.__callback","text":"__callback()\n\n\nSee callback from OrdinaryDiffEq.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTFlows.__reltol-Tuple{}","page":"Developers","title":"CTFlows.__reltol","text":"__reltol() -> Float64\n\n\nDefault relative tolerance for ODE solvers.\n\nSee reltol from OrdinaryDiffEq.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTFlows.__saveat-Tuple{}","page":"Developers","title":"CTFlows.__saveat","text":"__saveat() -> Vector{Any}\n\n\nSee saveat from OrdinaryDiffEq.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTFlows.__tstops-Tuple{}","page":"Developers","title":"CTFlows.__tstops","text":"__tstops() -> Vector{Real}\n\n\nSee tstops from OrdinaryDiffEq.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTFlows.hamiltonian_usage-NTuple{4, Any}","page":"Developers","title":"CTFlows.hamiltonian_usage","text":"hamiltonian_usage(\n    alg,\n    abstol,\n    reltol,\n    saveat;\n    kwargs_Flow...\n) -> Any\n\n\nReturns a function that solves ODE problem associated to Hamiltonian vector field.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTFlows.makeH-Tuple{CTBase.Dynamics, CTBase.ControlLaw, CTBase.Lagrange, Real, Real, CTBase.MixedConstraint, CTBase.Multiplier}","page":"Developers","title":"CTFlows.makeH","text":"makeH(\n    f::CTBase.Dynamics,\n    u::CTBase.ControlLaw,\n    f⁰::CTBase.Lagrange,\n    p⁰::Real,\n    s::Real,\n    g::CTBase.MixedConstraint,\n    μ::CTBase.Multiplier\n) -> CTFlows.var\"#H#68\"\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + s p⁰ f⁰(t, x, u(t, x, p)) + μ(t, x, p) ⋅ g(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTFlows.makeH-Tuple{CTBase.Dynamics, CTBase.ControlLaw, CTBase.Lagrange, Real, Real}","page":"Developers","title":"CTFlows.makeH","text":"makeH(\n    f::CTBase.Dynamics,\n    u::CTBase.ControlLaw,\n    f⁰::CTBase.Lagrange,\n    p⁰::Real,\n    s::Real\n) -> CTFlows.var\"#H#66\"\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + s p⁰ f⁰(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTFlows.makeH-Tuple{CTBase.Dynamics, CTBase.ControlLaw, CTBase.MixedConstraint, CTBase.Multiplier}","page":"Developers","title":"CTFlows.makeH","text":"makeH(\n    f::CTBase.Dynamics,\n    u::CTBase.ControlLaw,\n    g::CTBase.MixedConstraint,\n    μ::CTBase.Multiplier\n) -> CTFlows.var\"#H#67\"\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + μ(t, x, p) ⋅ g(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTFlows.makeH-Tuple{CTBase.Dynamics, CTBase.ControlLaw}","page":"Developers","title":"CTFlows.makeH","text":"makeH(\n    f::CTBase.Dynamics,\n    u::CTBase.ControlLaw\n) -> CTFlows.var\"#64#65\"\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p f(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTFlows.ode_usage-NTuple{4, Any}","page":"Developers","title":"CTFlows.ode_usage","text":"ode_usage(\n    alg,\n    abstol,\n    reltol,\n    saveat;\n    kwargs_Flow...\n) -> Any\n\n\nReturns a function that solves any ODE problem with OrdinaryDiffEq.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTFlows.rhs-Tuple{CTBase.AbstractHamiltonian}","page":"Developers","title":"CTFlows.rhs","text":"rhs(h::CTBase.AbstractHamiltonian) -> CTFlows.var\"#rhs!#24\"\n\n\nThe right and side from a Hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTFlows.vector_field_usage-NTuple{4, Any}","page":"Developers","title":"CTFlows.vector_field_usage","text":"vector_field_usage(\n    alg,\n    abstol,\n    reltol,\n    saveat;\n    kwargs_Flow...\n) -> Any\n\n\nReturns a function that solves ODE problem associated to classical vector field.\n\n\n\n\n\n","category":"method"},{"location":"index.html#CTFlows.jl","page":"Introduction","title":"CTFlows.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CurrentModule =  CTFlows","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The CTFlows.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"note: Install\nTo install a package from the control-toolbox ecosystem,  please visit the installation page.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"It aims to provide tools to solve mathematical flows of vector fields, and in particular Hamiltonian vector fields directly from the definition of the Hamiltonian, using automatic differentiation to construct the assiocated Hamiltonian vector field.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The flow is then computed thanks to DifferentialEquations.jl package.","category":"page"}]
}
