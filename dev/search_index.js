var documenterSearchIndex = {"docs":
[{"location":"types.html#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types.html#Index","page":"Types","title":"Index","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"Pages   = [\"types.md\"]\nModules = [CTFlows]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"types.html","page":"Types","title":"Types","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTFlows\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTFlows\njulia> x = 1\njulia> CTFlows.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTFlows: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"types.html#Documentation","page":"Types","title":"Documentation","text":"","category":"section"},{"location":"types.html#CTFlows.Control","page":"Types","title":"CTFlows.Control","text":"Alias for control input variables (scalar or vector).\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.Costate","page":"Types","title":"CTFlows.Costate","text":"Alias for the costate (adjoint) variable (scalar or vector).\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.DCostate","page":"Types","title":"CTFlows.DCostate","text":"Alias for derivatives of the costate (scalar or vector).\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.DState","page":"Types","title":"CTFlows.DState","text":"Alias for derivatives of the state (scalar or vector).\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.State","page":"Types","title":"CTFlows.State","text":"Alias for the system state (scalar or vector).\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.Variable","page":"Types","title":"CTFlows.Variable","text":"Alias for generic variables (scalar or vector).\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.ctVector","page":"Types","title":"CTFlows.ctVector","text":"Scalar or vector type used in continuous-time models (scalar or vector-valued).\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.AbstractHamiltonian","page":"Types","title":"CTFlows.AbstractHamiltonian","text":"abstract type AbstractHamiltonian{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.AbstractVectorField","page":"Types","title":"CTFlows.AbstractVectorField","text":"abstract type AbstractVectorField{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.Autonomous","page":"Types","title":"CTFlows.Autonomous","text":"abstract type Autonomous <: CTFlows.TimeDependence\n\nIndicates the function is autonomous: it does not explicitly depend on time t.\n\nFor example, dynamics of the form f(x, u, p).\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.ControlLaw","page":"Types","title":"CTFlows.ControlLaw","text":"struct ControlLaw{TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\nRepresents a generic open-loop or closed-loop control law.\n\nExample\n\njulia> f(t, x) = -x * exp(-t)\njulia> u = ControlLaw{typeof(f), NonAutonomous, Fixed}(f)\njulia> u(1.0, [2.0])\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.ControlLaw-Tuple{Function, Type{<:CTFlows.TimeDependence}, Type{<:CTFlows.VariableDependence}}","page":"Types","title":"CTFlows.ControlLaw","text":"ControlLaw(\n    f::Function,\n    TD::Type{<:CTFlows.TimeDependence},\n    VD::Type{<:CTFlows.VariableDependence}\n) -> CTFlows.ControlLaw\n\n\nConstruct a ControlLaw specifying time and variable dependence types.\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.ControlLaw-Tuple{Function}","page":"Types","title":"CTFlows.ControlLaw","text":"ControlLaw(\n    f::Function;\n    autonomous,\n    variable\n) -> CTFlows.ControlLaw\n\n\nConstruct a ControlLaw wrapping the function f.\n\nArguments\n\nf::Function: The function defining the control law.\nautonomous::Bool: Whether the system is autonomous.\nvariable::Bool: Whether the function depends on additional variables.\n\nReturns\n\nA ControlLaw instance parameterized accordingly.\n\nExample\n\njulia> cl = ControlLaw((x, p) -> -p)\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.Dynamics","page":"Types","title":"CTFlows.Dynamics","text":"struct Dynamics{TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\nRepresents the system dynamics dx/dt = f(...).\n\nFields\n\nf: a callable of the form:\nf(x, u)\nf(t, x, u)\nf(x, u, v)\nf(t, x, u, v)\n\nExample\n\njulia> f(x, u) = x + u\njulia> dyn = Dynamics{typeof(f), Autonomous, Fixed}(f)\njulia> dyn([1.0], [2.0])\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.Dynamics-Tuple{Function, Type{<:CTFlows.TimeDependence}, Type{<:CTFlows.VariableDependence}}","page":"Types","title":"CTFlows.Dynamics","text":"Dynamics(\n    f::Function,\n    TD::Type{<:CTFlows.TimeDependence},\n    VD::Type{<:CTFlows.VariableDependence}\n) -> CTFlows.Dynamics\n\n\nCreate a Dynamics object with explicit time and variable dependence.\n\nArguments\n\nf::Function: The dynamics function.\nTD: Type indicating time dependence.\nVD: Type indicating variable dependence.\n\nReturns\n\nA Dynamics{typeof(f),TD,VD} object.\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.Dynamics-Tuple{Function}","page":"Types","title":"CTFlows.Dynamics","text":"Dynamics(\n    f::Function;\n    autonomous,\n    variable\n) -> CTFlows.Dynamics\n\n\nCreate a Dynamics object representing system dynamics.\n\nArguments\n\nf::Function: The dynamics function.\nautonomous::Bool (optional): Whether the dynamics are autonomous (time-independent). Defaults to __autonomous().\nvariable::Bool (optional): Whether the dynamics depend on variables (non-fixed). Defaults to __variable().\n\nReturns\n\nA Dynamics{typeof(f),TD,VD} object.\n\nDetails\n\nThe Dynamics object can be called with various signatures depending on time and variable dependence.\n\nExamples\n\njulia> f(x, u) = [x[2], -x[1] + u[1]]\njulia> dyn = Dynamics(f, autonomous=true, variable=false)\njulia> dyn([1.0, 0.0], [0.0])  # returns [0.0, -1.0]\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.FeedbackControl","page":"Types","title":"CTFlows.FeedbackControl","text":"struct FeedbackControl{TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\nRepresents a feedback control law: u = f(x) or u = f(t, x).\n\nExample\n\njulia> f(x) = -x\njulia> u = FeedbackControl{typeof(f), Autonomous, Fixed}(f)\njulia> u([1.0, -1.0])\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.FeedbackControl-Tuple{Function, Type{<:CTFlows.TimeDependence}, Type{<:CTFlows.VariableDependence}}","page":"Types","title":"CTFlows.FeedbackControl","text":"FeedbackControl(\n    f::Function,\n    TD::Type{<:CTFlows.TimeDependence},\n    VD::Type{<:CTFlows.VariableDependence}\n) -> CTFlows.FeedbackControl\n\n\nConstruct a FeedbackControl specifying time and variable dependence types.\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.FeedbackControl-Tuple{Function}","page":"Types","title":"CTFlows.FeedbackControl","text":"FeedbackControl(\n    f::Function;\n    autonomous,\n    variable\n) -> CTFlows.FeedbackControl\n\n\nConstruct a FeedbackControl wrapping the function f.\n\nArguments\n\nf::Function: The function defining the feedback control.\nautonomous::Bool: Whether the system is autonomous.\nvariable::Bool: Whether the function depends on additional variables.\n\nReturns\n\nA FeedbackControl instance parameterized accordingly.\n\nExample\n\njulia> fb = FeedbackControl(x -> -x)\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.Fixed","page":"Types","title":"CTFlows.Fixed","text":"abstract type Fixed <: CTFlows.VariableDependence\n\nIndicates the function has fixed standard arguments only.\n\nFor example, functions of the form f(t, x, p) without any extra variable argument.\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.Hamiltonian","page":"Types","title":"CTFlows.Hamiltonian","text":"struct Hamiltonian{TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence} <: CTFlows.AbstractHamiltonian{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\nEncodes the Hamiltonian function H = ⟨p, f⟩ + L in optimal control.\n\nFields\n\nf: a callable of the form:\nf(x, p)\nf(t, x, p)\nf(x, p, v)\nf(t, x, p, v)\n\nType Parameters\n\nTD: Autonomous or NonAutonomous\nVD: Fixed or NonFixed\n\nExample\n\njulia> Hf(x, p) = dot(p, [x[2], -x[1]])\njulia> H = Hamiltonian{typeof(Hf), Autonomous, Fixed}(Hf)\njulia> H([1.0, 0.0], [1.0, 1.0])\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.Hamiltonian-Tuple{Function, Type{<:CTFlows.TimeDependence}, Type{<:CTFlows.VariableDependence}}","page":"Types","title":"CTFlows.Hamiltonian","text":"Hamiltonian(\n    f::Function,\n    TD::Type{<:CTFlows.TimeDependence},\n    VD::Type{<:CTFlows.VariableDependence}\n) -> CTFlows.Hamiltonian\n\n\nConstruct a Hamiltonian function wrapper with explicit time and variable dependence types.\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.Hamiltonian-Tuple{Function}","page":"Types","title":"CTFlows.Hamiltonian","text":"Hamiltonian(\n    f::Function;\n    autonomous,\n    variable\n) -> CTFlows.Hamiltonian\n\n\nConstruct a Hamiltonian function wrapper.\n\nf: a function representing the Hamiltonian.\nautonomous: whether f is autonomous (default via __autonomous()).\nvariable: whether f depends on an extra variable argument (default via __variable()).\n\nReturns a Hamiltonian{TF, TD, VD} callable struct.\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.HamiltonianLift","page":"Types","title":"CTFlows.HamiltonianLift","text":"struct HamiltonianLift{TV<:CTFlows.VectorField, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence} <: CTFlows.AbstractHamiltonian{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\nLifts a vector field X into a Hamiltonian function using the canonical symplectic structure.\n\nThis is useful to convert a vector field into a Hamiltonian via the identity: H(x, p) = ⟨p, X(x)⟩.\n\nConstructor\n\nUse HamiltonianLift(X::VectorField) where X is a VectorField{...}.\n\nExample\n\nf(x) = [x[2], -x[1]]\njulia> X = VectorField{typeof(f), Autonomous, Fixed}(f)\njulia> H = HamiltonianLift(X)\njulia> H([1.0, 0.0], [0.5, 0.5])\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.HamiltonianLift-Tuple{Function, Type{<:CTFlows.TimeDependence}, Type{<:CTFlows.VariableDependence}}","page":"Types","title":"CTFlows.HamiltonianLift","text":"HamiltonianLift(\n    f::Function,\n    TD::Type{<:CTFlows.TimeDependence},\n    VD::Type{<:CTFlows.VariableDependence}\n) -> CTFlows.HamiltonianLift{CTFlows.VectorField{TF, TD, VD}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\n\nConstruct a HamiltonianLift with explicit time and variable dependence types.\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.HamiltonianLift-Tuple{Function}","page":"Types","title":"CTFlows.HamiltonianLift","text":"HamiltonianLift(\n    f::Function;\n    autonomous,\n    variable\n) -> CTFlows.HamiltonianLift{CTFlows.VectorField{TF, TD, VD}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\n\nConstruct a HamiltonianLift from a vector field function.\n\nf: function defining the vector field.\nautonomous: whether f is autonomous.\nvariable: whether f depends on an extra variable argument.\n\nReturns a HamiltonianLift wrapping the vector field.\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.HamiltonianVectorField","page":"Types","title":"CTFlows.HamiltonianVectorField","text":"struct HamiltonianVectorField{TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence} <: CTFlows.AbstractVectorField{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\nRepresents the Hamiltonian vector field associated to a Hamiltonian function, typically defined as (∂H/∂p, -∂H/∂x).\n\nFields\n\nf: a callable implementing the Hamiltonian vector field.\n\nExample\n\njulia> f(x, p) = [p[2], -p[1], -x[1], -x[2]]\njulia> XH = HamiltonianVectorField{typeof(f), Autonomous, Fixed}(f)\njulia> XH([1.0, 0.0], [0.5, 0.5])\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.HamiltonianVectorField-Tuple{Function, Type{<:CTFlows.TimeDependence}, Type{<:CTFlows.VariableDependence}}","page":"Types","title":"CTFlows.HamiltonianVectorField","text":"HamiltonianVectorField(\n    f::Function,\n    TD::Type{<:CTFlows.TimeDependence},\n    VD::Type{<:CTFlows.VariableDependence}\n) -> CTFlows.HamiltonianVectorField\n\n\nConstruct a Hamiltonian vector field with explicit time and variable dependence.\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.HamiltonianVectorField-Tuple{Function}","page":"Types","title":"CTFlows.HamiltonianVectorField","text":"HamiltonianVectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> CTFlows.HamiltonianVectorField\n\n\nConstruct a Hamiltonian vector field from a function f.\n\nautonomous: whether f is autonomous.\nvariable: whether f depends on an extra variable argument.\n\nReturns a HamiltonianVectorField{TF, TD, VD} callable struct.\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.Lagrange","page":"Types","title":"CTFlows.Lagrange","text":"struct Lagrange{TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\nEncodes the integrand L(t, x, u, ...) of the cost functional in Bolza optimal control problems.\n\nFields\n\nf: a callable such as:\nf(x, u)\nf(t, x, u)\nf(x, u, v)\nf(t, x, u, v)\n\nExample\n\njulia> L(x, u) = dot(x, x) + dot(u, u)\njulia> lag = Lagrange{typeof(L), Autonomous, Fixed}(L)\njulia> lag([1.0, 2.0], [0.5, 0.5])\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.Lagrange-Tuple{Function, Type{<:CTFlows.TimeDependence}, Type{<:CTFlows.VariableDependence}}","page":"Types","title":"CTFlows.Lagrange","text":"Lagrange(\n    f::Function,\n    TD::Type{<:CTFlows.TimeDependence},\n    VD::Type{<:CTFlows.VariableDependence}\n) -> CTFlows.Lagrange\n\n\nCreate a Lagrange object with explicit time and variable dependence.\n\nArguments\n\nf::Function: The Lagrangian function.\nTD: Type indicating time dependence.\nVD: Type indicating variable dependence.\n\nReturns\n\nA Lagrange{typeof(f),TD,VD} object.\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.Lagrange-Tuple{Function}","page":"Types","title":"CTFlows.Lagrange","text":"Lagrange(\n    f::Function;\n    autonomous,\n    variable\n) -> CTFlows.Lagrange\n\n\nCreate a Lagrange object representing a Lagrangian cost function.\n\nArguments\n\nf::Function: The Lagrangian function.\nautonomous::Bool (optional): Whether f is autonomous (time-independent). Defaults to __autonomous().\nvariable::Bool (optional): Whether f depends on variables (non-fixed). Defaults to __variable().\n\nReturns\n\nA Lagrange{typeof(f),TD,VD} object.\n\nDetails\n\nThe Lagrange object can be called with different argument signatures depending on the time and variable dependence.\n\nExamples\n\njulia> f(x, u) = sum(abs2, x) + sum(abs2, u)\njulia> lag = Lagrange(f, autonomous=true, variable=false)\njulia> lag([1.0, 2.0], [0.5, 0.5])  # returns 5.25\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.Mayer","page":"Types","title":"CTFlows.Mayer","text":"struct Mayer{TF<:Function, VD<:CTFlows.VariableDependence}\n\nEncodes the Mayer cost function in optimal control problems.\n\nThis terminal cost term is usually of the form φ(x(tf)) or φ(t, x(tf), v), depending on whether it's autonomous and/or variable-dependent.\n\nFields\n\nf: a callable of the form:\nf(x)\nf(x, v)\nf(t, x)\nf(t, x, v) depending on time and variable dependency.\n\nExample\n\njulia> φ(x) = norm(x)^2\njulia> m = Mayer{typeof(φ), Fixed}(φ)\njulia> m([1.0, 2.0])\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.Mayer-Tuple{Function, Type{<:CTFlows.VariableDependence}}","page":"Types","title":"CTFlows.Mayer","text":"Mayer(\n    f::Function,\n    VD::Type{<:CTFlows.VariableDependence}\n) -> CTFlows.Mayer\n\n\nConstruct a Mayer cost functional wrapper with explicit variable dependence type VD.\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.Mayer-Tuple{Function}","page":"Types","title":"CTFlows.Mayer","text":"Mayer(f::Function; variable) -> CTFlows.Mayer\n\n\nConstruct a Mayer cost functional wrapper.\n\nf: a function representing the Mayer cost.\nvariable: whether the function depends on an extra variable argument (default via __variable()).\n\nReturns a Mayer{TF, VD} callable struct where:\n\nTF is the function type\nVD is either Fixed or NonFixed depending on variable.\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.MixedConstraint","page":"Types","title":"CTFlows.MixedConstraint","text":"struct MixedConstraint{TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\nEncodes a constraint on both state and control: g(x, u) = 0 or g(t, x, u) = 0.\n\nExample\n\njulia> g(x, u) = x[1] + u[1] - 1\njulia> mc = MixedConstraint{typeof(g), Autonomous, Fixed}(g)\njulia> mc([0.3], [0.7])\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.MixedConstraint-Tuple{Function, Type{<:CTFlows.TimeDependence}, Type{<:CTFlows.VariableDependence}}","page":"Types","title":"CTFlows.MixedConstraint","text":"MixedConstraint(\n    f::Function,\n    TD::Type{<:CTFlows.TimeDependence},\n    VD::Type{<:CTFlows.VariableDependence}\n) -> CTFlows.MixedConstraint\n\n\nConstruct a MixedConstraint specifying the time and variable dependence types explicitly.\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.MixedConstraint-Tuple{Function}","page":"Types","title":"CTFlows.MixedConstraint","text":"MixedConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> CTFlows.MixedConstraint\n\n\nConstruct a MixedConstraint object wrapping the function f.\n\nArguments\n\nf::Function: The function defining the mixed constraint.\nautonomous::Bool: Whether the system is autonomous.\nvariable::Bool: Whether the function depends on additional variables.\n\nReturns\n\nA MixedConstraint instance parameterized by the type of f and time/variable dependence.\n\nExample\n\njulia> mc = MixedConstraint((x, u) -> x + u)\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.Multiplier","page":"Types","title":"CTFlows.Multiplier","text":"struct Multiplier{TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\nEncodes a Lagrange multiplier associated with a constraint.\n\nExample\n\njulia> λ(t) = [sin(t), cos(t)]\njulia> μ = Multiplier{typeof(λ), NonAutonomous, Fixed}(λ)\njulia> μ(π / 2)\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.Multiplier-Tuple{Function, Type{<:CTFlows.TimeDependence}, Type{<:CTFlows.VariableDependence}}","page":"Types","title":"CTFlows.Multiplier","text":"Multiplier(\n    f::Function,\n    TD::Type{<:CTFlows.TimeDependence},\n    VD::Type{<:CTFlows.VariableDependence}\n) -> CTFlows.Multiplier\n\n\nConstruct a Multiplier specifying time and variable dependence types.\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.Multiplier-Tuple{Function}","page":"Types","title":"CTFlows.Multiplier","text":"Multiplier(\n    f::Function;\n    autonomous,\n    variable\n) -> CTFlows.Multiplier\n\n\nConstruct a Multiplier wrapping the function f.\n\nArguments\n\nf::Function: The function defining the multiplier.\nautonomous::Bool: Whether the system is autonomous.\nvariable::Bool: Whether the function depends on additional variables.\n\nReturns\n\nA Multiplier instance parameterized accordingly.\n\nExample\n\njulia> m = Multiplier((x, p) -> p .* x)\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.NonAutonomous","page":"Types","title":"CTFlows.NonAutonomous","text":"abstract type NonAutonomous <: CTFlows.TimeDependence\n\nIndicates the function is non-autonomous: it explicitly depends on time t.\n\nFor example, dynamics of the form f(t, x, u, p).\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.NonFixed","page":"Types","title":"CTFlows.NonFixed","text":"abstract type NonFixed <: CTFlows.VariableDependence\n\nIndicates the function has an additional variable argument v.\n\nFor example, functions of the form f(t, x, p, v) where v is a multiplier or auxiliary parameter.\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.StateConstraint","page":"Types","title":"CTFlows.StateConstraint","text":"struct StateConstraint{TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\nEncodes a pure state constraint g(x) = 0 or g(t, x) = 0.\n\nFields\n\nf: a callable depending on time or not, with or without variable dependency.\n\nExample\n\njulia> g(x) = x[1]^2 + x[2]^2 - 1\njulia> c = StateConstraint{typeof(g), Autonomous, Fixed}(g)\njulia> c([1.0, 0.0])\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.StateConstraint-Tuple{Function, Type{<:CTFlows.TimeDependence}, Type{<:CTFlows.VariableDependence}}","page":"Types","title":"CTFlows.StateConstraint","text":"StateConstraint(\n    f::Function,\n    TD::Type{<:CTFlows.TimeDependence},\n    VD::Type{<:CTFlows.VariableDependence}\n) -> CTFlows.StateConstraint\n\n\nConstruct a StateConstraint specifying the time and variable dependence types explicitly.\n\nArguments\n\nf::Function: The function defining the state constraint.\nTD::Type: The time dependence type (Autonomous or NonAutonomous).\nVD::Type: The variable dependence type (Fixed or NonFixed).\n\nReturns\n\nA StateConstraint instance parameterized accordingly.\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.StateConstraint-Tuple{Function}","page":"Types","title":"CTFlows.StateConstraint","text":"StateConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> CTFlows.StateConstraint\n\n\nConstruct a StateConstraint object wrapping the function f.\n\nArguments\n\nf::Function: The function defining the state constraint.\nautonomous::Bool: Whether the system is autonomous (default uses __autonomous()).\nvariable::Bool: Whether the function depends on additional variables (default uses __variable()).\n\nReturns\n\nA StateConstraint instance parameterized by the type of f and time/variable dependence.\n\nExample\n\njulia> sc = StateConstraint(x -> x .- 1)  # Autonomous, fixed variable by default\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.Time","page":"Types","title":"CTFlows.Time","text":"Alias for scalar time variables.\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.TimeDependence","page":"Types","title":"CTFlows.TimeDependence","text":"abstract type TimeDependence\n\nBase abstract type representing the dependence of a function on time.\n\nUsed as a trait to distinguish autonomous vs. non-autonomous functions.\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.Times","page":"Types","title":"CTFlows.Times","text":"Alias for a vector of time points.\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.VariableDependence","page":"Types","title":"CTFlows.VariableDependence","text":"abstract type VariableDependence\n\nBase abstract type representing whether a function depends on an additional variable argument.\n\nUsed to distinguish fixed-argument functions from those with auxiliary parameters.\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.VectorField","page":"Types","title":"CTFlows.VectorField","text":"struct VectorField{TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence} <: CTFlows.AbstractVectorField{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\nRepresents a dynamical system dx/dt = f(...) as a vector field.\n\nFields\n\nf: a callable of the form:\nf(x)\nf(t, x)\nf(x, v)\nf(t, x, v)\n\nExample\n\nf(x) = [x[2], -x[1]]\nvf = VectorField{typeof(f), Autonomous, Fixed}(f)\nvf([1.0, 0.0])\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTFlows.VectorField-Tuple{Function, Type{<:CTFlows.TimeDependence}, Type{<:CTFlows.VariableDependence}}","page":"Types","title":"CTFlows.VectorField","text":"VectorField(\n    f::Function,\n    TD::Type{<:CTFlows.TimeDependence},\n    VD::Type{<:CTFlows.VariableDependence}\n) -> CTFlows.VectorField\n\n\nCreate a VectorField object with explicit time and variable dependence types.\n\nArguments\n\nf::Function: The vector field function.\nTD: Type indicating time dependence (Autonomous or NonAutonomous).\nVD: Type indicating variable dependence (Fixed or NonFixed).\n\nReturns\n\nA VectorField{typeof(f),TD,VD} object.\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.VectorField-Tuple{Function}","page":"Types","title":"CTFlows.VectorField","text":"VectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> CTFlows.VectorField\n\n\nCreate a VectorField object wrapping the function f.\n\nArguments\n\nf::Function: The vector field function.\nautonomous::Bool (optional): If true, the vector field is autonomous (time-independent). Defaults to __autonomous().\nvariable::Bool (optional): If true, the vector field depends on control or decision variables (non-fixed). Defaults to __variable().\n\nReturns\n\nA VectorField{typeof(f),TD,VD} object where TD encodes time dependence and VD encodes variable dependence.\n\nDetails\n\nThe VectorField object can be called with different argument signatures depending on the time and variable dependence.\n\nExamples\n\njulia> f(x) = [-x[2], x[1]]\njulia> vf = VectorField(f, autonomous=true, variable=false)\njulia> vf([1.0, 0.0])  # returns [-0.0, 1.0]\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTFlows.ctNumber","page":"Types","title":"CTFlows.ctNumber","text":"Base scalar type used in continuous-time models, e.g. Float64 or Dual numbers.\n\n\n\n\n\n","category":"type"},{"location":"types.html","page":"Types","title":"Types","text":"","category":"page"},{"location":"differential_geometry.html#Differential-Geometry","page":"Differential Geometry","title":"Differential Geometry","text":"","category":"section"},{"location":"differential_geometry.html#Index","page":"Differential Geometry","title":"Index","text":"","category":"section"},{"location":"differential_geometry.html","page":"Differential Geometry","title":"Differential Geometry","text":"Pages   = [\"differential_geometry.md\"]\nModules = [CTFlows]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"differential_geometry.html","page":"Differential Geometry","title":"Differential Geometry","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTFlows\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTFlows\njulia> x = 1\njulia> CTFlows.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTFlows: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"differential_geometry.html#Documentation","page":"Differential Geometry","title":"Documentation","text":"","category":"section"},{"location":"differential_geometry.html#CTFlows.:⅋-Union{Tuple{V}, Tuple{CTFlows.VectorField{<:Function, CTFlows.Autonomous, V}, CTFlows.VectorField{<:Function, CTFlows.Autonomous, V}}} where V<:CTFlows.VariableDependence","page":"Differential Geometry","title":"CTFlows.:⅋","text":"\"Directional derivative\" of a vector field in the autonomous case, used internally for computing the Lie bracket.\n\nExample:\n\njulia> X = VectorField(x -> [x[2], -x[1]])\njulia> Y = VectorField(x -> [x[1], x[2]])\njulia> (X ⅋ Y)([1, 2])\n[2, -1]\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.:⅋-Union{Tuple{V}, Tuple{CTFlows.VectorField{<:Function, CTFlows.NonAutonomous, V}, CTFlows.VectorField{<:Function, CTFlows.NonAutonomous, V}}} where V<:CTFlows.VariableDependence","page":"Differential Geometry","title":"CTFlows.:⅋","text":"\"Directional derivative\" of a vector field in the nonautonomous case, used internally for computing the Lie bracket.\n\nExample:\n\njulia> X = VectorField((t, x, v) -> [t + v[1] + v[2] + x[2], -x[1]], NonFixed, NonAutonomous)\njulia> Y = VectorField((t, x, v) ->  [v[1] + v[2] + x[1], x[2]], NonFixed, NonAutonomous)\njulia> (X ⅋ Y)(1, [1, 2], [2, 3])\n[8, -1]\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.:⋅-Tuple{CTFlows.VectorField{<:Function, CTFlows.Autonomous}, Function}","page":"Differential Geometry","title":"CTFlows.:⋅","text":"Lie derivative of a scalar function along a vector field in the autonomous case.\n\nExample:\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (X⋅f)([1, 2])\n0\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.:⋅-Tuple{CTFlows.VectorField{<:Function, CTFlows.NonAutonomous}, Function}","page":"Differential Geometry","title":"CTFlows.:⋅","text":"Lie derivative of a scalar function along a vector field in the nonautonomous case.\n\nExample:\n\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (X⋅f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.:⋅-Tuple{Function, Function}","page":"Differential Geometry","title":"CTFlows.:⋅","text":"Lie derivative of a scalar function along a function (considered autonomous and non-variable).\n\nExample:\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (φ⋅f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (φ⋅f)(1, [1, 2], [2, 1])\nMethodError\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Lie-Tuple{CTFlows.VectorField, Function}","page":"Differential Geometry","title":"CTFlows.Lie","text":"Lie derivative of a scalar function along a vector field.\n\nExample:\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(X,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(X, f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Lie-Tuple{Function, Function}","page":"Differential Geometry","title":"CTFlows.Lie","text":"Lie derivative of a scalar function along a function with specified dependencies.\n\nExample:\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, autonomous=false, variable=true)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Lie-Union{Tuple{V}, Tuple{CTFlows.VectorField{<:Function, CTFlows.Autonomous, V}, CTFlows.VectorField{<:Function, CTFlows.Autonomous, V}}} where V<:CTFlows.VariableDependence","page":"Differential Geometry","title":"CTFlows.Lie","text":"Lie bracket of two vector fields in the autonomous case.\n\nExample:\n\njulia> f = x -> [x[2], 2x[1]]\njulia> g = x -> [3x[2], -x[1]]\njulia> X = VectorField(f)\njulia> Y = VectorField(g)\njulia> Lie(X, Y)([1, 2])\n[7, -14]\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Lie-Union{Tuple{V}, Tuple{CTFlows.VectorField{<:Function, CTFlows.NonAutonomous, V}, CTFlows.VectorField{<:Function, CTFlows.NonAutonomous, V}}} where V<:CTFlows.VariableDependence","page":"Differential Geometry","title":"CTFlows.Lie","text":"Lie bracket of two vector fields in the nonautonomous case.\n\nExample:\n\njulia> f = (t, x, v) -> [t + x[2] + v, -2x[1] - v]\njulia> g = (t, x, v) -> [t + 3x[2] + v, -x[1] - v]\njulia> X = VectorField(f, NonAutonomous, NonFixed)\njulia> Y = VectorField(g, NonAutonomous, NonFixed)\njulia> Lie(X, Y)(1, [1, 2], 1)\n[-7, 12]\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Lift-Tuple{CTFlows.VectorField}","page":"Differential Geometry","title":"CTFlows.Lift","text":"Lift(\n    X::CTFlows.VectorField\n) -> CTFlows.HamiltonianLift{CTFlows.VectorField{TF, TD, VD}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\n\nConstruct the Hamiltonian lift of a VectorField.\n\nArguments\n\nX::VectorField: The vector field to lift. Its signature determines if it is autonomous and/or variable.\n\nReturns\n\nA HamiltonianLift callable object representing the Hamiltonian lift of X.\n\nExamples\n\njulia> HL = Lift(VectorField(x -> [x[1]^2, x[2]^2], autonomous=true, variable=false))\njulia> HL([1, 0], [0, 1])  # returns 0\n\njulia> HL2 = Lift(VectorField((t, x, v) -> [t + x[1]^2, x[2]^2 + v], autonomous=false, variable=true))\njulia> HL2(1, [1, 0], [0, 1], 1)  # returns 1\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)  # returns 2\n\njulia> H2 = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H2(1, 1, 1, 1)  # returns 2\n\n# Alternative syntax using symbols for autonomy and variability\njulia> H3 = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H3(1, 1, 1, 1)  # returns 2\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Lift-Tuple{Function}","page":"Differential Geometry","title":"CTFlows.Lift","text":"Lift(\n    X::Function;\n    autonomous,\n    variable\n) -> CTFlows.var\"#19#23\"{<:Function}\n\n\nConstruct the Hamiltonian lift of a function.\n\nArguments\n\nX::Function: The function representing the vector field.\nautonomous::Bool=true: Whether the function is autonomous (time-independent).\nvariable::Bool=false: Whether the function depends on an additional variable argument.\n\nReturns\n\nA callable function computing the Hamiltonian lift, \n\n(and variants depending on autonomous and variable).\n\nDetails\n\nDepending on the autonomous and variable flags, the returned function has one of the following call signatures:\n\n(x, p) if autonomous=true and variable=false\n(x, p, v) if autonomous=true and variable=true\n(t, x, p) if autonomous=false and variable=false\n(t, x, p, v) if autonomous=false and variable=true\n\nExamples\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)  # returns 2\n\njulia> H2 = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H2(1, 1, 1, 1)  # returns 2\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Poisson-Tuple{Function, Function}","page":"Differential Geometry","title":"CTFlows.Poisson","text":"Poisson(\n    f::Function,\n    g::Function;\n    autonomous,\n    variable\n) -> CTFlows.Hamiltonian\n\n\nPoisson bracket of two functions. The time and variable dependence are specified with keyword arguments.\n\nReturns a Hamiltonian computed from the functions promoted as Hamiltonians.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])     # -20\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, autonomous=false, variable=true)(2, [1, 2], [2, 1], [4, 4])     # -76\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Poisson-Union{Tuple{VD}, Tuple{TD}, Tuple{CTFlows.AbstractHamiltonian{TD, VD}, Function}} where {TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}","page":"Differential Geometry","title":"CTFlows.Poisson","text":"Poisson(\n    f::CTFlows.AbstractHamiltonian{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence},\n    g::Function\n) -> CTFlows.Hamiltonian\n\n\nPoisson bracket of a Hamiltonian and a function.\n\nReturns a Hamiltonian representing {f, g} where f is already a Hamiltonian.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> Poisson(F, g)([1, 2], [2, 1])     # -20\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> Poisson(F, g)(2, [1, 2], [2, 1], [4, 4])     # -76\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Poisson-Union{Tuple{VD}, Tuple{TD}, Tuple{Function, CTFlows.AbstractHamiltonian{TD, VD}}} where {TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}","page":"Differential Geometry","title":"CTFlows.Poisson","text":"Poisson(\n    f::Function,\n    g::CTFlows.AbstractHamiltonian{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n) -> CTFlows.Hamiltonian\n\n\nPoisson bracket of a function and a Hamiltonian.\n\nReturns a Hamiltonian representing {f, g} where g is already a Hamiltonian.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1]\njulia> G = Hamiltonian(g)\njulia> Poisson(f, G)([1, 2], [2, 1])     # -20\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(f, G)(2, [1, 2], [2, 1], [4, 4])     # -76\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Poisson-Union{Tuple{V}, Tuple{CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V}, CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V}}} where V<:CTFlows.VariableDependence","page":"Differential Geometry","title":"CTFlows.Poisson","text":"Poisson(\n    f::CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V<:CTFlows.VariableDependence},\n    g::CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian). Autonomous case.\n\nReturns a Hamiltonian representing the Poisson bracket {f, g} of two autonomous Hamiltonian functions f and g.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> G = Hamiltonian(g)\njulia> Poisson(f, g)([1, 2], [2, 1])     # -20\njulia> Poisson(f, G)([1, 2], [2, 1])     # -20\njulia> Poisson(F, g)([1, 2], [2, 1])     # -20\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Poisson-Union{Tuple{V}, Tuple{CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V}, CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V}}} where V<:CTFlows.VariableDependence","page":"Differential Geometry","title":"CTFlows.Poisson","text":"Poisson(\n    f::CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V<:CTFlows.VariableDependence},\n    g::CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\nPoisson bracket of two Hamiltonian functions. Non-autonomous case.\n\nReturns a Hamiltonian representing {f, g} where f and g are time-dependent.\n\nExample\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])     # -76\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])     # -76\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{CTFlows.HamiltonianLift{T, V}, CTFlows.HamiltonianLift{T, V}}} where {T<:CTFlows.TimeDependence, V<:CTFlows.VariableDependence}","page":"Differential Geometry","title":"CTFlows.Poisson","text":"Poisson(\n    f::CTFlows.HamiltonianLift{T<:CTFlows.TimeDependence, V<:CTFlows.VariableDependence},\n    g::CTFlows.HamiltonianLift{T<:CTFlows.TimeDependence, V<:CTFlows.VariableDependence}\n)\n\n\nPoisson bracket of two HamiltonianLift vector fields.\n\nReturns the HamiltonianLift corresponding to the Lie bracket of vector fields f.X and g.X.\n\nExample\n\njulia> f = x -> [x[1]^2 + x[2]^2, 2x[1]^2]\njulia> g = x -> [3x[2]^2, x[2] - x[1]^2]\njulia> F = Lift(f)\njulia> G = Lift(g)\njulia> Poisson(F, G)([1, 2], [2, 1])     # -64\n\njulia> f = (t, x, v) -> [t*v[1]*x[2]^2, 2x[1]^2 + v[2]]\njulia> g = (t, x, v) -> [3x[2]^2 - x[1]^2, t - v[2]]\njulia> F = Lift(f, NonAutonomous, NonFixed)\njulia> G = Lift(g, NonAutonomous, NonFixed)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])     # 100\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.∂ₜ-Tuple{Any}","page":"Differential Geometry","title":"CTFlows.∂ₜ","text":"Partial derivative with respect to time of a function.\n\nExample:\n\njulia> ∂ₜ((t,x) -> t*x)(0,8)\n8\n\n\n\n\n\n","category":"method"},{"location":"differential_geometry.html#CTFlows.@Lie-Tuple{Expr, Vararg{Any}}","page":"Differential Geometry","title":"CTFlows.@Lie","text":"Compute Lie or Poisson brackets.\n\nThis macro provides a unified notation to define recursively nested Lie brackets (for vector fields) or Poisson brackets (for Hamiltonians).\n\nSyntax\n\n@Lie [F, G]: computes the Lie bracket [F, G] of two vector fields.\n@Lie [[F, G], H]: supports arbitrarily nested Lie brackets.\n@Lie {H, K}: computes the Poisson bracket {H, K} of two Hamiltonians.\n@Lie {{H, K}, L}: supports arbitrarily nested Poisson brackets.\n@Lie expr autonomous = false: specifies a non-autonomous system.\n@Lie expr variable = true: indicates presence of an auxiliary variable v.\n\nKeyword-like arguments can be provided to control the evaluation context for Poisson brackets with raw functions:\n\nautonomous = Bool: whether the system is time-independent (default: true).\nvariable = Bool: whether the system depends on an extra variable v (default: false).\n\nBracket type detection\n\nSquare brackets [...] denote Lie brackets between VectorField objects.\nCurly brackets {...} denote Poisson brackets between Hamiltonian objects or between raw functions.\nThe macro automatically dispatches to Lie or Poisson depending on the input pattern.\n\nReturn\n\nA callable object representing the specified Lie or Poisson bracket expression. The returned function can be evaluated like any other vector field or Hamiltonian.\n\n\n\nExamples\n\n■ Lie brackets with VectorField (autonomous)\n\njulia> F1 = VectorField(x -> [0, -x[3], x[2]])\njulia> F2 = VectorField(x -> [x[3], 0, -x[1]])\njulia> L = @Lie [F1, F2]\njulia> L([1.0, 2.0, 3.0])\n3-element Vector{Float64}:\n  2.0\n -1.0\n  0.0\n\n■ Lie brackets with VectorField (non-autonomous, with auxiliary variable)\n\njulia> F1 = VectorField((t, x, v) -> [0, -x[3], x[2]]; autonomous=false, variable=true)\njulia> F2 = VectorField((t, x, v) -> [x[3], 0, -x[1]]; autonomous=false, variable=true)\njulia> L = @Lie [F1, F2]\njulia> L(0.0, [1.0, 2.0, 3.0], 1.0)\n3-element Vector{Float64}:\n  2.0\n -1.0\n  0.0\n\n■ Poisson brackets with Hamiltonian (autonomous)\n\njulia> H1 = Hamiltonian((x, p) -> x[1]^2 + p[2]^2)\njulia> H2 = Hamiltonian((x, p) -> x[2]^2 + p[1]^2)\njulia> P = @Lie {H1, H2}\njulia> P([1.0, 1.0], [3.0, 2.0])\n-4.0\n\n■ Poisson brackets with Hamiltonian (non-autonomous, with variable)\n\njulia> H1 = Hamiltonian((t, x, p, v) -> x[1]^2 + p[2]^2 + v; autonomous=false, variable=true)\njulia> H2 = Hamiltonian((t, x, p, v) -> x[2]^2 + p[1]^2 + v; autonomous=false, variable=true)\njulia> P = @Lie {H1, H2}\njulia> P(1.0, [1.0, 3.0], [4.0, 2.0], 3.0)\n8.0\n\n■ Poisson brackets from raw functions\n\njulia> H1 = (x, p) -> x[1]^2 + p[2]^2\njulia> H2 = (x, p) -> x[2]^2 + p[1]^2\njulia> P = @Lie {H1, H2}\njulia> P([1.0, 1.0], [3.0, 2.0])\n-4.0\n\n■ Poisson bracket with non-autonomous raw functions\n\njulia> H1 = (t, x, p) -> x[1]^2 + p[2]^2 + t\njulia> H2 = (t, x, p) -> x[2]^2 + p[1]^2 + t\njulia> P = @Lie {H1, H2} autonomous = false\njulia> P(3.0, [1.0, 2.0], [4.0, 1.0])\n-8.0\n\n■ Nested brackets\n\njulia> F = VectorField(x -> [-x[1], x[2], x[3]])\njulia> G = VectorField(x -> [x[3], -x[2], 0])\njulia> H = VectorField(x -> [0, 0, -x[1]])\njulia> nested = @Lie [[F, G], H]\njulia> nested([1.0, 2.0, 3.0])\n3-element Vector{Float64}:\n  2.0\n  0.0\n -6.0\n\njulia> H1 = (x, p) -> x[2]*x[1]^2 + p[1]^2\njulia> H2 = (x, p) -> x[1]*p[2]^2\njulia> H3 = (x, p) -> x[1]*p[2] + x[2]*p[1]\njulia> nested_poisson = @Lie {{H1, H2}, H3}\njulia> nested_poisson([1.0, 2.0], [0.5, 1.0])\n14.0\n\n■ Mixed expressions with arithmetic\n\njulia> F1 = VectorField(x -> [0, -x[3], x[2]])\njulia> F2 = VectorField(x -> [x[3], 0, -x[1]])\njulia> x = [1.0, 2.0, 3.0]\njulia> @Lie [F1, F2](x) + 3 * [F1, F2](x)\n3-element Vector{Float64}:\n  8.0\n -4.0\n  0.0\n\njulia> H1 = (x, p) -> x[1]^2\njulia> H2 = (x, p) -> p[1]^2\njulia> H3 = (x, p) -> x[1]*p[1]\njulia> x = [1.0, 2.0, 3.0]\njulia> p = [3.0, 2.0, 1.0]\njulia> @Lie {H1, H2}(x, p) + 2 * {H2, H3}(x, p)\n24.0\n\n\n\n\n\n","category":"macro"},{"location":"differential_geometry.html","page":"Differential Geometry","title":"Differential Geometry","text":"","category":"page"},{"location":"vector_field.html#Vector-Field","page":"Vector Field","title":"Vector Field","text":"","category":"section"},{"location":"vector_field.html#Index","page":"Vector Field","title":"Index","text":"","category":"section"},{"location":"vector_field.html","page":"Vector Field","title":"Vector Field","text":"Pages   = [\"vector_field.md\"]\nModules = [CTFlows, CTFlowsODE]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"vector_field.html","page":"Vector Field","title":"Vector Field","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTFlows\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTFlows\njulia> x = 1\njulia> CTFlows.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTFlows: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"vector_field.html#Documentation","page":"Vector Field","title":"Documentation","text":"","category":"section"},{"location":"vector_field.html#CTFlows.Flow-Tuple{CTFlows.VectorField}","page":"Vector Field","title":"CTFlows.Flow","text":"Flow(\n    vf::CTFlows.VectorField;\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.VectorFieldFlow\n\n\nConstructs a flow object for a classical (non-Hamiltonian) vector field.\n\nThis creates a VectorFieldFlow that integrates the ODE system dx/dt = vf(t, x, v) using DifferentialEquations.jl. It handles both fixed and parametric dynamics, as well as jump discontinuities and event stopping.\n\nKeyword Arguments\n\nalg, abstol, reltol, saveat, internalnorm: Solver options.\nkwargs_Flow...: Additional arguments passed to the solver configuration.\n\nExample\n\njulia> vf(t, x, v) = -v * x\njulia> flow = CTFlows.Flow(CTFlows.VectorField(vf))\njulia> x1 = flow(0.0, 1.0, 1.0)\n\n\n\n\n\n","category":"method"},{"location":"vector_field.html#CTFlowsODE.vector_field_usage-NTuple{5, Any}","page":"Vector Field","title":"CTFlowsODE.vector_field_usage","text":"vector_field_usage(\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm;\n    kwargs_Flow...\n) -> Any\n\n\nReturns a function that solves the ODE associated with a classical vector field.\n\nThis utility creates a flow integrator for systems of the form dx/dt = f(t, x, v), where x is the state and v is an external parameter. It supports integration over a time span as well as direct queries for final state evaluation.\n\nTwo overloads are returned:\n\nf(tspan, x0, v=default_variable; kwargs...) returns the full solution trajectory.\nf(t0, x0, tf, v=default_variable; kwargs...) returns only the final state x(tf).\n\nInternally uses OrdinaryDiffEq.solve, with support for stopping times and jump discontinuities.\n\nArguments\n\nalg: Integration algorithm (e.g. Tsit5()).\nabstol, reltol: Absolute and relative tolerances.\nsaveat: Output time step or vector of times.\ninternalnorm: Norm used for adaptive integration.\nkwargs_Flow...: Default solver options (overridden by explicit kwargs at call site).\n\nExample\n\njulia> vf = (t, x, v) -> -v * x\njulia> flowfun = vector_field_usage(Tsit5(), 1e-8, 1e-8, 0.1, norm)\njulia> xf = flowfun(0.0, 1.0, 1.0, 2.0)\n\n\n\n\n\n","category":"method"},{"location":"vector_field.html","page":"Vector Field","title":"Vector Field","text":"","category":"page"},{"location":"default.html#Default","page":"Default","title":"Default","text":"","category":"section"},{"location":"default.html#Index","page":"Default","title":"Index","text":"","category":"section"},{"location":"default.html","page":"Default","title":"Default","text":"Pages   = [\"default.md\"]\nModules = [CTFlows]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"default.html","page":"Default","title":"Default","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTFlows\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTFlows\njulia> x = 1\njulia> CTFlows.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTFlows: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"default.html#Documentation","page":"Default","title":"Documentation","text":"","category":"section"},{"location":"default.html#CTFlows.__autonomous-Tuple{CTModels.Model{CTModels.Autonomous}}","page":"Default","title":"CTFlows.__autonomous","text":"__autonomous(_::CTModels.Model{CTModels.Autonomous}) -> Bool\n\n\nReturn true for a model declared as CTModels.Autonomous.\n\nUsed to determine whether a model has time-independent dynamics.\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTFlows.__autonomous-Tuple{CTModels.Model{CTModels.NonAutonomous}}","page":"Default","title":"CTFlows.__autonomous","text":"__autonomous(\n    _::CTModels.Model{CTModels.NonAutonomous}\n) -> Bool\n\n\nReturn false for a model declared as CTModels.NonAutonomous.\n\nUsed to identify models whose dynamics depend explicitly on time.\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTFlows.__autonomous-Tuple{}","page":"Default","title":"CTFlows.__autonomous","text":"__autonomous() -> Bool\n\n\nReturn true by default, assuming the problem is autonomous.\n\nThis is the fallback for generic cases when no model is provided.\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTFlows.__variable-Tuple{CTModels.Model}","page":"Default","title":"CTFlows.__variable","text":"__variable(ocp::CTModels.Model) -> Bool\n\n\nReturn true if the model has one or more external variables.\n\nUsed to check whether the problem is parameterized by an external vector v.\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTFlows.__variable-Tuple{}","page":"Default","title":"CTFlows.__variable","text":"__variable() -> Bool\n\n\nReturn false by default, assuming no external variable is used.\n\nFallback for cases where no model is given.\n\n\n\n\n\n","category":"method"},{"location":"default.html","page":"Default","title":"Default","text":"","category":"page"},{"location":"optimal_control_problem.html#Optimal-Control-Problem","page":"Optimal Control Problem","title":"Optimal Control Problem","text":"","category":"section"},{"location":"optimal_control_problem.html#Index","page":"Optimal Control Problem","title":"Index","text":"","category":"section"},{"location":"optimal_control_problem.html","page":"Optimal Control Problem","title":"Optimal Control Problem","text":"Pages   = [\"optimal_control_problem.md\"]\nModules = [CTFlows, CTFlowsODE]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"optimal_control_problem.html","page":"Optimal Control Problem","title":"Optimal Control Problem","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTFlows\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTFlows\njulia> x = 1\njulia> CTFlows.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTFlows: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"optimal_control_problem.html#Documentation","page":"Optimal Control Problem","title":"Documentation","text":"","category":"section"},{"location":"optimal_control_problem.html#CTFlows.Flow-Tuple{CTModels.Model, CTFlows.ControlLaw}","page":"Optimal Control Problem","title":"CTFlows.Flow","text":"Flow(\n    ocp::CTModels.Model,\n    u::CTFlows.ControlLaw;\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.OptimalControlFlow\n\n\nConstruct a flow for an optimal control problem using a given control law.\n\nThis method builds the Hamiltonian system associated with the optimal control problem (ocp) and integrates the corresponding state–costate dynamics using the specified control law u.\n\nArguments\n\nocp::CTModels.Model: An optimal control problem defined using CTModels.\nu::CTFlows.ControlLaw: A feedback control law generated by ControlLaw(...) or similar.\nalg: Integration algorithm (default inferred).\nabstol: Absolute tolerance for the ODE solver.\nreltol: Relative tolerance for the ODE solver.\nsaveat: Time points at which to save the solution.\ninternalnorm: Optional norm function used by the integrator.\nkwargs_Flow: Additional keyword arguments passed to the solver.\n\nReturns\n\nA flow object f such that:\n\nf(t0, x0, p0, tf) integrates the state and costate from t0 to tf.\nf((t0, tf), x0, p0) returns the full trajectory over the interval.\n\nExample\n\njulia> u = (x, p) -> p\njulia> f = Flow(ocp, ControlLaw(u))\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem.html#CTFlows.Flow-Tuple{CTModels.Model, Function, Function, Function}","page":"Optimal Control Problem","title":"CTFlows.Flow","text":"Flow(\n    ocp::CTModels.Model,\n    u::Function,\n    g::Function,\n    μ::Function;\n    autonomous,\n    variable,\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.OptimalControlFlow\n\n\nConstruct a flow from a raw feedback control, constraint, and multiplier.\n\nThis version is for defining flows directly from user functions without wrapping them into ControlLaw, Constraint, or Multiplier types. Automatically wraps and adapts them based on time dependence.\n\nArguments\n\nocp::CTModels.Model: The optimal control problem.\nu::Function: Control law.\ng::Function: Constraint.\nμ::Function: Multiplier.\nautonomous::Bool: Whether the system is autonomous.\nvariable::Bool: Whether time is a free variable.\nalg, abstol, reltol, saveat, internalnorm: Solver parameters.\nkwargs_Flow: Additional options.\n\nReturns\n\nA Flow object ready for trajectory integration.\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem.html#CTFlows.Flow-Tuple{CTModels.Model, Function}","page":"Optimal Control Problem","title":"CTFlows.Flow","text":"Flow(\n    ocp::CTModels.Model,\n    u::Function;\n    autonomous,\n    variable,\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.OptimalControlFlow\n\n\nConstruct a flow for an optimal control problem using a control function in feedback form.\n\nThis method constructs the Hamiltonian and integrates the associated state–costate dynamics using a raw function u. It automatically wraps u as a control law.\n\nArguments\n\nocp::CTModels.Model: The optimal control problem.\nu::Function: A feedback control function:\nIf ocp is autonomous: u(x, p)\nIf non-autonomous: u(t, x, p)\nautonomous::Bool: Whether the control law depends on time.\nvariable::Bool: Whether the OCP involves variable time (e.g., free final time).\nalg, abstol, reltol, saveat, internalnorm: ODE solver parameters.\nkwargs_Flow: Additional options.\n\nReturns\n\nA Flow object compatible with function call interfaces for state propagation.\n\nExample\n\njulia> u = (t, x, p) -> t + p\njulia> f = Flow(ocp, u)\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem.html#CTFlows.Flow-Union{Tuple{V}, Tuple{T}, Tuple{CTModels.Model, Union{CTFlows.ControlLaw{<:Function, T, V}, CTFlows.FeedbackControl{<:Function, T, V}}, Union{CTFlows.MixedConstraint{<:Function, T, V}, CTFlows.StateConstraint{<:Function, T, V}}, CTFlows.Multiplier{<:Function, T, V}}} where {T, V}","page":"Optimal Control Problem","title":"CTFlows.Flow","text":"Flow(\n    ocp::CTModels.Model,\n    u::Union{CTFlows.ControlLaw{<:Function, T, V}, CTFlows.FeedbackControl{<:Function, T, V}},\n    g::Union{CTFlows.MixedConstraint{<:Function, T, V}, CTFlows.StateConstraint{<:Function, T, V}},\n    μ::CTFlows.Multiplier{<:Function, T, V};\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.OptimalControlFlow\n\n\nConstruct a flow for an optimal control problem with control and constraint multipliers in feedback form.\n\nThis variant constructs a Hamiltonian system incorporating both the control law and a multiplier law (e.g., for enforcing state or mixed constraints). All inputs must be consistent in time dependence.\n\nArguments\n\nocp::CTModels.Model: The optimal control problem.\nu::ControlLaw or FeedbackControl: Feedback control.\ng::StateConstraint or MixedConstraint: Constraint function.\nμ::Multiplier: Multiplier function.\nalg, abstol, reltol, saveat, internalnorm: Solver settings.\nkwargs_Flow: Additional options.\n\nReturns\n\nA Flow object that integrates the constrained Hamiltonian dynamics.\n\nExample\n\njulia> f = Flow(ocp, (x, p) -> p[1], (x, u) -> x[1] - 1, (x, p) -> x[1]+p[1])\n\nFor non-autonomous cases:\n\njulia> f = Flow(ocp, (t, x, p) -> t + p, (t, x, u) -> x - 1, (t, x, p) -> x+p)\n\nwarning: Warning\nAll input functions must match the autonomous/non-autonomous nature of the problem.\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem.html#CTFlowsODE.__ocp_Flow-Tuple{CTModels.Model, CTFlows.Hamiltonian, CTFlows.ControlLaw, Vararg{Any, 5}}","page":"Optimal Control Problem","title":"CTFlowsODE.__ocp_Flow","text":"__ocp_Flow(\n    ocp::CTModels.Model,\n    h::CTFlows.Hamiltonian,\n    u::CTFlows.ControlLaw,\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm;\n    kwargs_Flow...\n) -> CTFlowsODE.OptimalControlFlow\n\n\nInternal helper: builds the OptimalControlFlow object from a Hamiltonian and control law.\n\nThis function assembles the RHS, constructs the integrator, and packages the flow object.\n\nArguments\n\nocp: The original optimal control problem.\nh: A Hamiltonian structure.\nu: A control law.\nalg, abstol, reltol, saveat, internalnorm: Integration parameters.\nkwargs_Flow: Additional parameters.\n\nReturns\n\nAn OptimalControlFlow object, callable as a function for integration.\n\nnote: Note\nThis function is internal and intended for constructing flows behind the scenes.\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem.html","page":"Optimal Control Problem","title":"Optimal Control Problem","text":"","category":"page"},{"location":"ext_types.html#Extension-Types","page":"Extension Types","title":"Extension Types","text":"","category":"section"},{"location":"ext_types.html#Index","page":"Extension Types","title":"Index","text":"","category":"section"},{"location":"ext_types.html","page":"Extension Types","title":"Extension Types","text":"Pages   = [\"ext_types.md\"]\nModules = [CTFlows, CTFlowsODE, CTModels]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"ext_types.html","page":"Extension Types","title":"Extension Types","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTFlows\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTFlows\njulia> x = 1\njulia> CTFlows.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTFlows: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"ext_types.html#Documentation","page":"Extension Types","title":"Documentation","text":"","category":"section"},{"location":"ext_types.html#CTFlowsODE.HamiltonianFlow","page":"Extension Types","title":"CTFlowsODE.HamiltonianFlow","text":"struct HamiltonianFlow <: CTFlowsODE.AbstractFlow{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}\n\nA flow object for integrating Hamiltonian dynamics in optimal control.\n\nRepresents the time evolution of a Hamiltonian system using the canonical form of Hamilton's equations. The struct holds the numerical integration setup and metadata for event handling.\n\nFields\n\nf::Function: Flow integrator function, called like f(t0, x0, p0, tf; ...).\nrhs!::Function: Right-hand side of the ODE system, used by solvers.\ntstops::Times: List of times at which integration should pause or apply discrete effects.\njumps::Vector{Tuple{Time,Costate}}: List of jump discontinuities for the costate at given times.\n\nUsage\n\nInstances of HamiltonianFlow are callable and forward arguments to the underlying flow function f.\n\nExample\n\njulia> flow = HamiltonianFlow(f, rhs!)\njulia> xf, pf = flow(0.0, x0, p0, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"ext_types.html#CTFlowsODE.ODEFlow","page":"Extension Types","title":"CTFlowsODE.ODEFlow","text":"struct ODEFlow <: CTFlowsODE.AbstractFlow{Any, Any}\n\nGeneric flow object for arbitrary ODE systems with jumps and events.\n\nA catch-all flow for general-purpose ODE integration. Supports dynamic typing and arbitrary state structures.\n\nFields\n\nf::Function: Integrator function called with time span and initial conditions.\nrhs::Function: Right-hand side for the differential equation.\ntstops::Times: Times at which the integrator is forced to stop.\njumps::Vector{Tuple{Time,Any}}: User-defined jumps applied to the state during integration.\n\nExample\n\njulia> flow = ODEFlow(f, rhs)\njulia> result = flow(0.0, u0, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"ext_types.html#CTFlowsODE.OptimalControlFlow","page":"Extension Types","title":"CTFlowsODE.OptimalControlFlow","text":"struct OptimalControlFlow{VD} <: CTFlowsODE.AbstractFlow{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}\n\nA flow object representing the solution of an optimal control problem.\n\nSupports Hamiltonian-based and classical formulations. Provides call overloads for different control settings:\n\nFixed external variables\nParametric (non-fixed) control problems\n\nFields\n\nf::Function: Main integrator that receives the RHS and other arguments.\nrhs!::Function: ODE right-hand side.\ntstops::Times: Times where the solver should stop (e.g., nonsmooth dynamics).\njumps::Vector{Tuple{Time,Costate}}: Costate jump conditions.\nfeedback_control::ControlLaw: Feedback law u(t, x, p, v).\nocp::Model: The optimal control problem definition.\nkwargs_Flow::Any: Extra solver arguments.\n\nCall Signatures\n\nF(t0, x0, p0, tf; kwargs...): Solves with fixed variable dimension.\nF(t0, x0, p0, tf, v; kwargs...): Solves with parameter v.\nF(tspan, x0, p0; ...): Solves and returns a full OptimalControlSolution.\n\nExample\n\njulia> flow = OptimalControlFlow(...)\njulia> sol = flow(0.0, x0, p0, 1.0)\njulia> opt_sol = flow((0.0, 1.0), x0, p0)\n\n\n\n\n\n","category":"type"},{"location":"ext_types.html#CTFlowsODE.OptimalControlFlowSolution","page":"Extension Types","title":"CTFlowsODE.OptimalControlFlowSolution","text":"struct OptimalControlFlowSolution\n\nWraps the low-level ODE solution, control feedback law, model structure, and problem parameters.\n\nFields\n\node_sol::Any: The ODE solution (from DifferentialEquations.jl).\nfeedback_control::ControlLaw: Feedback control law u(t, x, p, v).\nocp::Model: The optimal control model used.\nvariable::Variable: External or design parameters of the control problem.\n\nUsage\n\nYou can evaluate the flow solution like a callable ODE solution.\n\nExample\n\njulia> sol = OptimalControlFlowSolution(ode_sol, u, model, v)\njulia> x = sol(t)\n\n\n\n\n\n","category":"type"},{"location":"ext_types.html#CTFlowsODE.VectorFieldFlow","page":"Extension Types","title":"CTFlowsODE.VectorFieldFlow","text":"struct VectorFieldFlow <: CTFlowsODE.AbstractFlow{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}\n\nA flow object for integrating general vector field dynamics.\n\nUsed for systems where the vector field is given explicitly, rather than derived from a Hamiltonian. Useful in settings like controlled systems or classical mechanics outside the Hamiltonian framework.\n\nFields\n\nf::Function: Flow integrator function.\nrhs::Function: ODE right-hand side function.\ntstops::Times: Event times (e.g., to trigger callbacks).\njumps::Vector{Tuple{Time,State}}: Discrete jump events on the state trajectory.\n\nExample\n\njulia> flow = VectorFieldFlow(f, rhs)\njulia> xf = flow(0.0, x0, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"ext_types.html#CTModels.Solution-Tuple{CTFlowsODE.OptimalControlFlowSolution}","page":"Extension Types","title":"CTModels.Solution","text":"Solution(\n    ocfs::CTFlowsODE.OptimalControlFlowSolution;\n    kwargs...\n) -> CTModels.Solution{TimeGridModelType, TimesModelType, StateModelType, ControlModelType, VariableModelType, CostateModelType, Float64, DualModelType, CTModels.SolverInfos{Dict{Symbol, Any}}, ModelType} where {TimeGridModelType<:CTModels.TimeGridModel, TimesModelType<:CTModels.TimesModel, StateModelType<:Union{CTModels.StateModelSolution{CTModels.var\"#114#136\"{CTFlowsODE.var\"#8#15\"{CTFlowsODE.var\"#x#11\"{CTFlowsODE.OptimalControlFlowSolution, Int64}}}}, CTModels.StateModelSolution{CTModels.var\"#115#137\"{CTFlowsODE.var\"#8#15\"{CTFlowsODE.var\"#x#11\"{CTFlowsODE.OptimalControlFlowSolution, Int64}}}}}, ControlModelType<:Union{CTModels.ControlModelSolution{CTModels.var\"#116#138\"{CTFlowsODE.var\"#9#16\"{CTFlowsODE.var\"#u#13\"{CTFlowsODE.OptimalControlFlowSolution, CTFlowsODE.var\"#p#12\"{CTFlowsODE.OptimalControlFlowSolution, Int64}, CTFlowsODE.var\"#x#11\"{CTFlowsODE.OptimalControlFlowSolution, Int64}}}}}, CTModels.ControlModelSolution{CTModels.var\"#117#139\"{CTFlowsODE.var\"#9#16\"{CTFlowsODE.var\"#u#13\"{CTFlowsODE.OptimalControlFlowSolution, CTFlowsODE.var\"#p#12\"{CTFlowsODE.OptimalControlFlowSolution, Int64}, CTFlowsODE.var\"#x#11\"{CTFlowsODE.OptimalControlFlowSolution, Int64}}}}}}, VariableModelType<:Union{CTModels.VariableModelSolution{Vector{Float64}}, CTModels.VariableModelSolution{Float64}}, CostateModelType<:Union{CTModels.var\"#118#140\"{CTFlowsODE.var\"#10#17\"{CTFlowsODE.var\"#p#12\"{CTFlowsODE.OptimalControlFlowSolution, Int64}}}, CTModels.var\"#119#141\"{CTFlowsODE.var\"#10#17\"{CTFlowsODE.var\"#p#12\"{CTFlowsODE.OptimalControlFlowSolution, Int64}}}}, DualModelType<:(CTModels.DualModel{PC_Dual, BC_Dual, SC_LB_Dual, SC_UB_Dual, CC_LB_Dual, CC_UB_Dual, VC_LB_Dual, VC_UB_Dual} where {PC_Dual<:Union{Nothing, CTModels.var\"#121#143\", CTModels.var\"#122#144\"}, BC_Dual<:Union{Nothing, Vector{Float64}}, SC_LB_Dual<:Union{Nothing, CTModels.var\"#124#146\", CTModels.var\"#125#147\"}, SC_UB_Dual<:Union{Nothing, CTModels.var\"#127#149\", CTModels.var\"#128#150\"}, CC_LB_Dual<:Union{Nothing, CTModels.var\"#130#152\", CTModels.var\"#131#153\"}, CC_UB_Dual<:Union{Nothing, CTModels.var\"#133#155\", CTModels.var\"#134#156\"}, VC_LB_Dual<:Union{Nothing, Vector{Float64}}, VC_UB_Dual<:Union{Nothing, Vector{Float64}}}), ModelType<:CTModels.Model}\n\n\nConstructs an OptimalControlSolution from an OptimalControlFlowSolution.\n\nThis evaluates the objective (Mayer and/or Lagrange costs), extracts the time-dependent state, costate, and control trajectories, and builds a full CTModels.Solution.\n\nReturns a CTModels.Solution ready for evaluation, reporting, or analysis.\n\nKeyword Arguments\n\nalg: Optional solver for computing Lagrange integral, if needed.\nAdditional kwargs passed to the internal solver.\n\nExample\n\njulia> sol = Solution(optflow_solution)\n\n\n\n\n\n","category":"method"},{"location":"ext_types.html","page":"Extension Types","title":"Extension Types","text":"","category":"page"},{"location":"utils.html#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"utils.html#Index","page":"Utils","title":"Index","text":"","category":"section"},{"location":"utils.html","page":"Utils","title":"Utils","text":"Pages   = [\"utils.md\"]\nModules = [CTFlows]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"utils.html","page":"Utils","title":"Utils","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTFlows\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTFlows\njulia> x = 1\njulia> CTFlows.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTFlows: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"utils.html#Documentation","page":"Utils","title":"Documentation","text":"","category":"section"},{"location":"utils.html#CTFlows.ctgradient","page":"Utils","title":"CTFlows.ctgradient","text":"ctgradient(f::Function, x::Real) -> Any\n\n\nCompute the derivative of a scalar function f at a scalar point x.\n\nArguments\n\nf::Function: A scalar-valued function.\nx::ctNumber: A scalar input.\n\nReturns\n\nThe derivative of f evaluated at x.\n\nExample\n\njulia> ctgradient(x -> x^2, 3.0)  # returns 6.0\n\n\n\n\n\nctgradient(f::Function, x) -> Any\n\n\nCompute the gradient of a scalar function f at a vector point x.\n\nArguments\n\nf::Function: A scalar-valued function accepting a vector input.\nx: A vector of numbers.\n\nReturns\n\nA vector representing the gradient ∇f(x).\n\nExample\n\njulia> ctgradient(x -> sum(x.^2), [1.0, 2.0])  # returns [2.0, 4.0]\n\n\n\n\n\nctgradient(X::CTFlows.VectorField, x) -> Any\n\n\nCompute the gradient of a VectorField at a given point.\n\nArguments\n\nX::VectorField: A vector field object with a callable function X.f.\nx: A scalar or vector input.\n\nReturns\n\nThe derivative or gradient depending on the type of x.\n\nExample\n\njulia> X = VectorField(x -> x^2)\njulia> ctgradient(X, 2.0)  # returns 4.0\n\n\n\n\n\n","category":"function"},{"location":"utils.html#CTFlows.ctjacobian","page":"Utils","title":"CTFlows.ctjacobian","text":"ctjacobian(f::Function, x::Real) -> Any\n\n\nCompute the Jacobian of a vector-valued function f at a scalar point x.\n\nArguments\n\nf::Function: A vector-valued function.\nx::ctNumber: A scalar input.\n\nReturns\n\nA matrix representing the Jacobian Jf(x).\n\nExample\n\njulia> f(x) = [sin(x), cos(x)]\njulia> ctjacobian(f, 0.0)  # returns a 2×1 matrix\n\n\n\n\n\nctjacobian(f::Function, x) -> Any\n\n\nCompute the Jacobian of a vector-valued function f at a vector point x.\n\nArguments\n\nf::Function: A vector-valued function.\nx: A vector input.\n\nReturns\n\nA matrix representing the Jacobian Jf(x).\n\nExample\n\njulia> f(x) = [x[1]^2, x[2]^2]\njulia> ctjacobian(f, [1.0, 2.0])  # returns [2.0 0.0; 0.0 4.0]\n\n\n\n\n\nctjacobian(X::CTFlows.VectorField, x) -> Any\n\n\nCompute the Jacobian of a VectorField at a given point.\n\nArguments\n\nX::VectorField: A vector field object with a callable function X.f.\nx: A scalar or vector input.\n\nReturns\n\nA matrix representing the Jacobian of X at x.\n\nExample\n\njulia> X = VectorField(x -> [x[1]^2, x[2]])\njulia> ctjacobian(X, [1.0, 3.0])  # returns [2.0 0.0; 0.0 1.0]\n\n\n\n\n\n","category":"function"},{"location":"utils.html","page":"Utils","title":"Utils","text":"","category":"page"},{"location":"optimal_control_problem_utils.html#Optimal-Control-Problem-Utils","page":"Optimal Control Problem Utils","title":"Optimal Control Problem Utils","text":"","category":"section"},{"location":"optimal_control_problem_utils.html#Index","page":"Optimal Control Problem Utils","title":"Index","text":"","category":"section"},{"location":"optimal_control_problem_utils.html","page":"Optimal Control Problem Utils","title":"Optimal Control Problem Utils","text":"Pages   = [\"optimal_control_problem_utils.md\"]\nModules = [CTFlows]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"optimal_control_problem_utils.html","page":"Optimal Control Problem Utils","title":"Optimal Control Problem Utils","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTFlows\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTFlows\njulia> x = 1\njulia> CTFlows.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTFlows: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"optimal_control_problem_utils.html#Documentation","page":"Optimal Control Problem Utils","title":"Documentation","text":"","category":"section"},{"location":"optimal_control_problem_utils.html#CTFlows.__create_hamiltonian-Tuple{CTModels.Model, Function, Any, Any}","page":"Optimal Control Problem Utils","title":"CTFlows.__create_hamiltonian","text":"__create_hamiltonian(\n    ocp::CTModels.Model,\n    u::Function,\n    g,\n    μ;\n    autonomous,\n    variable\n)\n\n\nOverload for control law as a raw function with autonomous and variable flags.\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem_utils.html#CTFlows.__create_hamiltonian-Tuple{CTModels.Model, Function}","page":"Optimal Control Problem Utils","title":"CTFlows.__create_hamiltonian","text":"__create_hamiltonian(\n    ocp::CTModels.Model,\n    u::Function;\n    autonomous,\n    variable\n)\n\n\nHelper method to construct the Hamiltonian when control is given as a plain function.\n\nThe function is wrapped in a ControlLaw, and the flags autonomous and variable define its behavior type.\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem_utils.html#CTFlows.__create_hamiltonian-Union{Tuple{V}, Tuple{T}, Tuple{CTModels.Model, CTFlows.ControlLaw{<:Function, T, V}, CTFlows.MixedConstraint{<:Function, T, V}, CTFlows.Multiplier{<:Function, T, V}}} where {T, V}","page":"Optimal Control Problem Utils","title":"CTFlows.__create_hamiltonian","text":"__create_hamiltonian(\n    ocp::CTModels.Model,\n    u::CTFlows.ControlLaw{<:Function, T, V},\n    g::CTFlows.MixedConstraint{<:Function, T, V},\n    μ::CTFlows.Multiplier{<:Function, T, V}\n) -> Tuple{Union{CTFlows.Hamiltonian{CTFlows.var\"#H#101\"{f, u, g, μ}, CTFlows.NonAutonomous, CTFlows.NonFixed} where {f, u, g, μ}, CTFlows.Hamiltonian{CTFlows.var\"#H#102\"{f, u, f⁰, p⁰, s, g, μ}, CTFlows.NonAutonomous, CTFlows.NonFixed} where {f, u, f⁰, p⁰, s, g, μ}}, CTFlows.ControlLaw{<:Function, T, V} where {T, V}}\n\n\nConstruct the Hamiltonian for a constrained optimal control problem.\n\nThis function supports multiple input types for the control law (u), path constraints (g), and multipliers (μ),  automatically adapting to autonomous/non-autonomous systems and fixed/non-fixed parameters.\n\nSupported input types\n\nu can be:\na raw function,\na ControlLaw object,\nor a FeedbackControl object.\ng can be:\na plain constraint function,\na MixedConstraint,\nor a StateConstraint.\nμ can be:\na function,\nor a Multiplier object.\n\nThe function normalizes these inputs to the appropriate types internally using multiple dispatch and pattern matching.\n\nArguments\n\nocp::CTModels.Model: The continuous-time optimal control problem.\nu: Control law, flexible input type as described.\ng: Path constraint, flexible input type as described.\nμ: Multiplier associated with the constraints.\nautonomous::Bool (optional keyword): Specifies if the system is autonomous.\nvariable::Bool (optional keyword): Specifies if the system parameters are variable.\n\nReturns\n\n(H, u): Tuple containing the Hamiltonian object H and the processed control law u.\n\nExamples\n\n# Using a raw function control law with autonomous system and fixed parameters\nH, u_processed = __create_hamiltonian(ocp, u_function, g_function, μ_function; autonomous=true, variable=false)\n\n# Using a FeedbackControl control law\nH, u_processed = __create_hamiltonian(ocp, feedback_control, g_constraint, μ_multiplier)\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem_utils.html#CTFlows.__create_hamiltonian-Union{Tuple{V}, Tuple{T}, Tuple{CTModels.Model, CTFlows.ControlLaw{<:Function, T, V}, CTFlows.MixedConstraint{<:Function, T, V}, Function}} where {T, V}","page":"Optimal Control Problem Utils","title":"CTFlows.__create_hamiltonian","text":"__create_hamiltonian(\n    ocp::CTModels.Model,\n    u::CTFlows.ControlLaw{<:Function, T, V},\n    g::CTFlows.MixedConstraint{<:Function, T, V},\n    μ::Function\n) -> Tuple{Union{CTFlows.Hamiltonian{CTFlows.var\"#H#101\"{f, u, g, μ}, CTFlows.NonAutonomous, CTFlows.NonFixed} where {f, u, g, μ}, CTFlows.Hamiltonian{CTFlows.var\"#H#102\"{f, u, f⁰, p⁰, s, g, μ}, CTFlows.NonAutonomous, CTFlows.NonFixed} where {f, u, f⁰, p⁰, s, g, μ}}, CTFlows.ControlLaw}\n\n\nOverload that wraps multiplier functions into Multiplier objects.\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem_utils.html#CTFlows.__create_hamiltonian-Union{Tuple{V}, Tuple{T}, Tuple{CTModels.Model, CTFlows.ControlLaw{<:Function, T, V}, CTFlows.StateConstraint{<:Function, T, V}, Any}} where {T, V}","page":"Optimal Control Problem Utils","title":"CTFlows.__create_hamiltonian","text":"__create_hamiltonian(\n    ocp::CTModels.Model,\n    u::CTFlows.ControlLaw{<:Function, T, V},\n    g_::CTFlows.StateConstraint{<:Function, T, V},\n    μ\n) -> Tuple{Union{CTFlows.Hamiltonian{CTFlows.var\"#H#101\"{f, u, g, μ}, CTFlows.NonAutonomous, CTFlows.NonFixed} where {f, u, g, μ}, CTFlows.Hamiltonian{CTFlows.var\"#H#102\"{f, u, f⁰, p⁰, s, g, μ}, CTFlows.NonAutonomous, CTFlows.NonFixed} where {f, u, f⁰, p⁰, s, g, μ}}, CTFlows.ControlLaw}\n\n\nOverload that converts StateConstraint objects into MixedConstraint with appropriate signature adaptation.\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem_utils.html#CTFlows.__create_hamiltonian-Union{Tuple{V}, Tuple{T}, Tuple{CTModels.Model, CTFlows.ControlLaw{<:Function, T, V}, Function, Any}} where {T, V}","page":"Optimal Control Problem Utils","title":"CTFlows.__create_hamiltonian","text":"__create_hamiltonian(\n    ocp::CTModels.Model,\n    u::CTFlows.ControlLaw{<:Function, T, V},\n    g::Function,\n    μ\n) -> Tuple{Union{CTFlows.Hamiltonian{CTFlows.var\"#H#101\"{f, u, g, μ}, CTFlows.NonAutonomous, CTFlows.NonFixed} where {f, u, g, μ}, CTFlows.Hamiltonian{CTFlows.var\"#H#102\"{f, u, f⁰, p⁰, s, g, μ}, CTFlows.NonAutonomous, CTFlows.NonFixed} where {f, u, f⁰, p⁰, s, g, μ}}, CTFlows.ControlLaw}\n\n\nOverload that wraps plain constraint functions into MixedConstraint objects.\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem_utils.html#CTFlows.__create_hamiltonian-Union{Tuple{V}, Tuple{T}, Tuple{CTModels.Model, CTFlows.ControlLaw{<:Function, T, V}}} where {T, V}","page":"Optimal Control Problem Utils","title":"CTFlows.__create_hamiltonian","text":"__create_hamiltonian(\n    ocp::CTModels.Model,\n    u::CTFlows.ControlLaw{<:Function, T, V}\n) -> Tuple{Union{CTFlows.Hamiltonian{CTFlows.var\"#98#99\"{f, u}, CTFlows.NonAutonomous, CTFlows.NonFixed} where {f, u}, CTFlows.Hamiltonian{CTFlows.var\"#H#100\"{f, u, f⁰, p⁰, s}, CTFlows.NonAutonomous, CTFlows.NonFixed} where {f, u, f⁰, p⁰, s}}, CTFlows.ControlLaw{<:Function, T, V} where {T, V}}\n\n\nConstruct and return the Hamiltonian for the given model and control law.\n\nThe Hamiltonian is built using model dynamics (and possibly a running cost) and returned as a callable function.\n\nReturns a tuple (H, u) where H is the Hamiltonian function and u is the control law.\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem_utils.html#CTFlows.__create_hamiltonian-Union{Tuple{V}, Tuple{T}, Tuple{CTModels.Model, CTFlows.FeedbackControl{<:Function, T, V}, Any, Any}} where {T, V}","page":"Optimal Control Problem Utils","title":"CTFlows.__create_hamiltonian","text":"__create_hamiltonian(\n    ocp::CTModels.Model,\n    u_::CTFlows.FeedbackControl{<:Function, T, V},\n    g,\n    μ\n) -> Any\n\n\nOverload for feedback control laws that adapts the signature based on autonomy and variability.\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem_utils.html#CTFlows.__dynamics-Tuple{CTModels.Model}","page":"Optimal Control Problem Utils","title":"CTFlows.__dynamics","text":"__dynamics(\n    ocp::CTModels.Model\n) -> CTFlows.Dynamics{CTFlows.var\"#78#79\"{ocp, n}, CTFlows.NonAutonomous, CTFlows.NonFixed} where {ocp, n}\n\n\nReturn a Dynamics object built from the model's right-hand side function.\n\nThe returned function computes the state derivative dx/dt = f(t, x, u, v),  wrapped to return either a scalar or vector depending on the model's state dimension.\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem_utils.html#CTFlows.__get_data_for_ocp_flow-Tuple{CTModels.Model}","page":"Optimal Control Problem Utils","title":"CTFlows.__get_data_for_ocp_flow","text":"__get_data_for_ocp_flow(\n    ocp::CTModels.Model\n) -> Tuple{CTFlows.Dynamics{CTFlows.var\"#78#79\"{ocp, n}, CTFlows.NonAutonomous, CTFlows.NonFixed} where {ocp, n}, Union{Nothing, CTFlows.Lagrange{<:Function, CTFlows.NonAutonomous, CTFlows.NonFixed}}, Int64, Float64}\n\n\nReturn internal components needed to construct the OCP Hamiltonian.\n\nReturns a tuple (f, f⁰, p⁰, s) where:\n\nf  : system dynamics (Dynamics)\nf⁰ : optional Lagrange integrand (Lagrange or nothing)\np⁰ : constant multiplier for cost (typically -1)\ns  : sign for minimization/maximization (+1 or -1)\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem_utils.html#CTFlows.__is_min-Tuple{CTModels.Model}","page":"Optimal Control Problem Utils","title":"CTFlows.__is_min","text":"__is_min(ocp::CTModels.Model) -> Bool\n\n\nReturn true if the given model defines a minimization problem, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem_utils.html#CTFlows.__lagrange-Tuple{CTModels.Model}","page":"Optimal Control Problem Utils","title":"CTFlows.__lagrange","text":"__lagrange(\n    ocp::CTModels.Model\n) -> Union{Nothing, CTFlows.Lagrange{<:Function, CTFlows.NonAutonomous, CTFlows.NonFixed}}\n\n\nReturn a Lagrange object if the model includes an integrand cost; otherwise, return nothing.\n\nThe resulting function can be used to compute the running cost of the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem_utils.html#CTFlows.__mayer-Tuple{CTModels.Model}","page":"Optimal Control Problem Utils","title":"CTFlows.__mayer","text":"__mayer(\n    ocp::CTModels.Model\n) -> Union{Nothing, CTFlows.Mayer{<:Function, CTFlows.NonFixed}}\n\n\nReturn a Mayer object if the model includes a terminal cost; otherwise, return nothing.\n\nThe resulting function can be used to compute the final cost in the objective.\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem_utils.html#CTFlows.makeH-Tuple{CTFlows.Dynamics, CTFlows.ControlLaw, CTFlows.Lagrange, Real, Real, CTFlows.MixedConstraint, CTFlows.Multiplier}","page":"Optimal Control Problem Utils","title":"CTFlows.makeH","text":"makeH(\n    f::CTFlows.Dynamics,\n    u::CTFlows.ControlLaw,\n    f⁰::CTFlows.Lagrange,\n    p⁰::Real,\n    s::Real,\n    g::CTFlows.MixedConstraint,\n    μ::CTFlows.Multiplier\n) -> CTFlows.var\"#H#102\"{CTFlows.Dynamics{TF, TD, VD}, CTFlows.ControlLaw{TF1, TD1, VD1}, CTFlows.Lagrange{TF2, TD2, VD2}, var\"#s182\", var\"#s1821\", CTFlows.MixedConstraint{TF3, TD3, VD3}, CTFlows.Multiplier{TF4, TD4, VD4}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence, TF1<:Function, TD1<:CTFlows.TimeDependence, VD1<:CTFlows.VariableDependence, TF2<:Function, TD2<:CTFlows.TimeDependence, VD2<:CTFlows.VariableDependence, var\"#s182\"<:Real, var\"#s1821\"<:Real, TF3<:Function, TD3<:CTFlows.TimeDependence, VD3<:CTFlows.VariableDependence, TF4<:Function, TD4<:CTFlows.TimeDependence, VD4<:CTFlows.VariableDependence}\n\n\nConstruct the Hamiltonian:\n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p))             + s p⁰ f⁰(t, x, u(t, x, p))             + μ(t, x, p) ⋅ g(t, x, u(t, x, p))\n\nCombines integrand cost and path constraints.\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem_utils.html#CTFlows.makeH-Tuple{CTFlows.Dynamics, CTFlows.ControlLaw, CTFlows.Lagrange, Real, Real}","page":"Optimal Control Problem Utils","title":"CTFlows.makeH","text":"makeH(\n    f::CTFlows.Dynamics,\n    u::CTFlows.ControlLaw,\n    f⁰::CTFlows.Lagrange,\n    p⁰::Real,\n    s::Real\n) -> CTFlows.var\"#H#100\"{CTFlows.Dynamics{TF, TD, VD}, CTFlows.ControlLaw{TF1, TD1, VD1}, CTFlows.Lagrange{TF2, TD2, VD2}, <:Real, <:Real} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence, TF1<:Function, TD1<:CTFlows.TimeDependence, VD1<:CTFlows.VariableDependence, TF2<:Function, TD2<:CTFlows.TimeDependence, VD2<:CTFlows.VariableDependence}\n\n\nConstruct the Hamiltonian:\n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + s p⁰ f⁰(t, x, u(t, x, p))\n\nIncludes a Lagrange integrand scaled by p⁰ and sign s.\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem_utils.html#CTFlows.makeH-Tuple{CTFlows.Dynamics, CTFlows.ControlLaw, CTFlows.MixedConstraint, CTFlows.Multiplier}","page":"Optimal Control Problem Utils","title":"CTFlows.makeH","text":"makeH(\n    f::CTFlows.Dynamics,\n    u::CTFlows.ControlLaw,\n    g::CTFlows.MixedConstraint,\n    μ::CTFlows.Multiplier\n) -> CTFlows.var\"#H#101\"{CTFlows.Dynamics{TF, TD, VD}, CTFlows.ControlLaw{TF1, TD1, VD1}, CTFlows.MixedConstraint{TF2, TD2, VD2}, CTFlows.Multiplier{TF3, TD3, VD3}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence, TF1<:Function, TD1<:CTFlows.TimeDependence, VD1<:CTFlows.VariableDependence, TF2<:Function, TD2<:CTFlows.TimeDependence, VD2<:CTFlows.VariableDependence, TF3<:Function, TD3<:CTFlows.TimeDependence, VD3<:CTFlows.VariableDependence}\n\n\nConstruct the Hamiltonian:\n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + μ(t, x, p) ⋅ g(t, x, u(t, x, p))\n\nIncludes state-control constraints and associated multipliers.\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem_utils.html#CTFlows.makeH-Tuple{CTFlows.Dynamics, CTFlows.ControlLaw}","page":"Optimal Control Problem Utils","title":"CTFlows.makeH","text":"makeH(\n    f::CTFlows.Dynamics,\n    u::CTFlows.ControlLaw\n) -> CTFlows.var\"#98#99\"{CTFlows.Dynamics{TF, TD, VD}, CTFlows.ControlLaw{TF1, TD1, VD1}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence, TF1<:Function, TD1<:CTFlows.TimeDependence, VD1<:CTFlows.VariableDependence}\n\n\nConstruct the Hamiltonian:\n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p))\n\nThe function returns a callable H(t, x, p, v) where v is an optional additional parameter.\n\n\n\n\n\n","category":"method"},{"location":"optimal_control_problem_utils.html","page":"Optimal Control Problem Utils","title":"Optimal Control Problem Utils","text":"","category":"page"},{"location":"concatenation.html#Concatenation","page":"Concatenation","title":"Concatenation","text":"","category":"section"},{"location":"concatenation.html#Index","page":"Concatenation","title":"Index","text":"","category":"section"},{"location":"concatenation.html","page":"Concatenation","title":"Concatenation","text":"Pages   = [\"concatenation.md\"]\nModules = [CTFlows, CTFlowsODE, Base]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"concatenation.html","page":"Concatenation","title":"Concatenation","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTFlows\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTFlows\njulia> x = 1\njulia> CTFlows.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTFlows: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"concatenation.html#Documentation","page":"Concatenation","title":"Documentation","text":"","category":"section"},{"location":"concatenation.html#Base.:*-Union{Tuple{TF}, Tuple{TF, Tuple{Real, Any, TF}}} where TF<:CTFlowsODE.AbstractFlow","page":"Concatenation","title":"Base.:*","text":"*(\n    F::CTFlowsODE.AbstractFlow,\n    g::Tuple{Real, Any, TF<:CTFlowsODE.AbstractFlow}\n) -> Any\n\n\nShorthand for concatenate(F, g) when g is a tuple (t_switch, η_switch, G) including a jump.\n\nArguments\n\nF::AbstractFlow: The first flow.\ng::Tuple{ctNumber, Any, AbstractFlow}: Tuple with switching time, jump value, and second flow.\n\nReturns\n\nA flow with a jump at t_switch and a switch from F to G.\n\nExample\n\njulia> F * (1.0, η, G)\n\n\n\n\n\n","category":"method"},{"location":"concatenation.html#Base.:*-Union{Tuple{TF}, Tuple{TF, Tuple{Real, TF}}} where TF<:CTFlowsODE.AbstractFlow","page":"Concatenation","title":"Base.:*","text":"*(\n    F::CTFlowsODE.AbstractFlow,\n    g::Tuple{Real, TF<:CTFlowsODE.AbstractFlow}\n) -> Any\n\n\nShorthand for concatenate(F, g) when g is a tuple (t_switch, G).\n\nArguments\n\nF::AbstractFlow: The first flow.\ng::Tuple{ctNumber, AbstractFlow}: Tuple containing the switching time and second flow.\n\nReturns\n\nA new flow that switches from F to G at t_switch.\n\nExample\n\njulia> F * (1.0, G)\n\n\n\n\n\n","category":"method"},{"location":"concatenation.html#CTFlowsODE.__concat_feedback_control-Tuple{CTFlowsODE.AbstractFlow, CTFlowsODE.AbstractFlow, Real}","page":"Concatenation","title":"CTFlowsODE.__concat_feedback_control","text":"__concat_feedback_control(\n    F::CTFlowsODE.AbstractFlow,\n    G::CTFlowsODE.AbstractFlow,\n    t_switch::Real\n) -> CTFlows.ControlLaw{CTFlowsODE.var\"#_feedback_control#73\"{F, G, t_switch}, CTFlows.NonAutonomous, CTFlows.NonFixed} where {F, G, t_switch}\n\n\nConcatenate feedback control laws of two optimal control flows.\n\nArguments\n\nF, G: OptimalControlFlow instances.\nt_switch::Time: Switching time.\n\nReturns\n\nA ControlLaw that dispatches to F or G depending on t.\n\nExample\n\njulia> u = __concat_feedback_control(F, G, 2.0)\njulia> u(1.5, x, u, v)  # from F\njulia> u(2.5, x, u, v)  # from G\n\n\n\n\n\n","category":"method"},{"location":"concatenation.html#CTFlowsODE.__concat_jumps","page":"Concatenation","title":"CTFlowsODE.__concat_jumps","text":"__concat_jumps(\n    F::CTFlowsODE.AbstractFlow,\n    G::CTFlowsODE.AbstractFlow\n) -> Any\n__concat_jumps(\n    F::CTFlowsODE.AbstractFlow,\n    G::CTFlowsODE.AbstractFlow,\n    jump::Union{Nothing, Tuple{Real, Any}}\n) -> Any\n\n\nConcatenate the jumps of two flows, with optional extra jump at t_switch.\n\nArguments\n\nF, G: Flows with jump events.\njump: Optional tuple (t_switch, η_switch) to insert.\n\nReturns\n\nCombined list of jumps.\n\nExample\n\njulia> __concat_jumps(F, G)\njulia> __concat_jumps(F, G, (1.0, η))\n\n\n\n\n\n","category":"function"},{"location":"concatenation.html#CTFlowsODE.__concat_rhs-Tuple{CTFlowsODE.ODEFlow, CTFlowsODE.ODEFlow, Real}","page":"Concatenation","title":"CTFlowsODE.__concat_rhs","text":"__concat_rhs(\n    F::CTFlowsODE.ODEFlow,\n    G::CTFlowsODE.ODEFlow,\n    t_switch::Real\n) -> CTFlowsODE.var\"#71#72\"{CTFlowsODE.ODEFlow, CTFlowsODE.ODEFlow, <:Real}\n\n\nConcatenate ODE right-hand sides with a switch at t_switch.\n\nArguments\n\nF, G: ODEFlow instances.\nt_switch::Time: Time at which to switch between flows.\n\nReturns\n\nA function of the form (x, v, t) -> ....\n\nExample\n\njulia> rhs = __concat_rhs(F, G, 0.5)\njulia> rhs(x, v, 0.4)  # F.rhs\njulia> rhs(x, v, 0.6)  # G.rhs\n\n\n\n\n\n","category":"method"},{"location":"concatenation.html#CTFlowsODE.__concat_rhs-Tuple{CTFlowsODE.VectorFieldFlow, CTFlowsODE.VectorFieldFlow, Real}","page":"Concatenation","title":"CTFlowsODE.__concat_rhs","text":"__concat_rhs(\n    F::CTFlowsODE.VectorFieldFlow,\n    G::CTFlowsODE.VectorFieldFlow,\n    t_switch::Real\n) -> CTFlowsODE.var\"#69#70\"{CTFlowsODE.VectorFieldFlow, CTFlowsODE.VectorFieldFlow, <:Real}\n\n\nConcatenate vector field right-hand sides with time-based switching.\n\nArguments\n\nF, G: VectorFieldFlow instances.\nt_switch::Time: Switching time.\n\nReturns\n\nA function of the form (x, v, t) -> ....\n\nExample\n\njulia> rhs = __concat_rhs(F, G, 2.0)\njulia> rhs(x, v, 1.0)  # uses F.rhs\njulia> rhs(x, v, 3.0)  # uses G.rhs\n\n\n\n\n\n","category":"method"},{"location":"concatenation.html#CTFlowsODE.__concat_rhs-Union{Tuple{U}, Tuple{D}, Tuple{CTFlowsODE.AbstractFlow{D, U}, CTFlowsODE.AbstractFlow{D, U}, Real}} where {D, U}","page":"Concatenation","title":"CTFlowsODE.__concat_rhs","text":"__concat_rhs(\n    F::CTFlowsODE.AbstractFlow{D, U},\n    G::CTFlowsODE.AbstractFlow{D, U},\n    t_switch::Real\n) -> CTFlowsODE.var\"#71#72\"{CTFlowsODE.ODEFlow, CTFlowsODE.ODEFlow, <:Real}\n\n\nConcatenate the right-hand sides of two flows F and G, switching at time t_switch.\n\nArguments\n\nF, G: Two flows of the same type.\nt_switch::Time: The switching time.\n\nReturns\n\nA function rhs! that dispatches to F.rhs! before t_switch, and to G.rhs! after.\n\nExample\n\njulia> rhs = __concat_rhs(F, G, 1.0)\njulia> rhs!(du, u, p, 0.5)  # uses F.rhs!\njulia> rhs!(du, u, p, 1.5)  # uses G.rhs!\n\n\n\n\n\n","category":"method"},{"location":"concatenation.html#CTFlowsODE.__concat_tstops-Tuple{CTFlowsODE.AbstractFlow, CTFlowsODE.AbstractFlow, Real}","page":"Concatenation","title":"CTFlowsODE.__concat_tstops","text":"__concat_tstops(\n    F::CTFlowsODE.AbstractFlow,\n    G::CTFlowsODE.AbstractFlow,\n    t_switch::Real\n) -> Any\n\n\nConcatenate the tstops (discontinuity times) of two flows and add the switching time.\n\nArguments\n\nF, G: Flows with tstops vectors.\nt_switch::Time: Switching time to include.\n\nReturns\n\nA sorted vector of unique tstops.\n\nExample\n\njulia> __concat_tstops(F, G, 1.0)\n\n\n\n\n\n","category":"method"},{"location":"concatenation.html#CTFlowsODE.concatenate-Union{Tuple{TF}, Tuple{TF, Tuple{Real, Any, TF}}} where TF<:CTFlowsODE.AbstractFlow","page":"Concatenation","title":"CTFlowsODE.concatenate","text":"concatenate(\n    F::CTFlowsODE.AbstractFlow,\n    g::Tuple{Real, Any, TF<:CTFlowsODE.AbstractFlow}\n) -> CTFlowsODE.OptimalControlFlow\n\n\nConcatenate two AbstractFlows and insert a jump at the switching time.\n\nArguments\n\nF::AbstractFlow\ng::Tuple{ctNumber,Any,AbstractFlow}: (t_switch, η_switch, G)\n\nReturns\n\nA concatenated flow with the jump included.\n\nExample\n\njulia> F * (1.0, η, G)\n\n\n\n\n\n","category":"method"},{"location":"concatenation.html#CTFlowsODE.concatenate-Union{Tuple{TF}, Tuple{TF, Tuple{Real, Any, TF}}} where TF<:CTFlowsODE.OptimalControlFlow","page":"Concatenation","title":"CTFlowsODE.concatenate","text":"concatenate(\n    F::CTFlowsODE.OptimalControlFlow,\n    g::Tuple{Real, Any, TF<:CTFlowsODE.OptimalControlFlow}\n) -> CTFlowsODE.OptimalControlFlow\n\n\nConcatenate two OptimalControlFlows and a jump at switching time.\n\nArguments\n\nF::OptimalControlFlow\ng::Tuple{ctNumber,Any,OptimalControlFlow}\n\nReturns\n\nA combined flow with jump and control law switching.\n\nExample\n\njulia> F * (1.0, η, G)\n\n\n\n\n\n","category":"method"},{"location":"concatenation.html#CTFlowsODE.concatenate-Union{Tuple{TF}, Tuple{TF, Tuple{Real, TF}}} where TF<:CTFlowsODE.AbstractFlow","page":"Concatenation","title":"CTFlowsODE.concatenate","text":"concatenate(\n    F::CTFlowsODE.AbstractFlow,\n    g::Tuple{Real, TF<:CTFlowsODE.AbstractFlow}\n) -> CTFlowsODE.OptimalControlFlow\n\n\nConcatenate two AbstractFlow instances with a prescribed switching time.\n\nArguments\n\nF::AbstractFlow: First flow.\ng::Tuple{ctNumber,AbstractFlow}: Switching time and second flow.\n\nReturns\n\nA new flow that transitions from F to G at t_switch.\n\nExample\n\njulia> F * (1.0, G)\n\n\n\n\n\n","category":"method"},{"location":"concatenation.html#CTFlowsODE.concatenate-Union{Tuple{TF}, Tuple{TF, Tuple{Real, TF}}} where TF<:CTFlowsODE.OptimalControlFlow","page":"Concatenation","title":"CTFlowsODE.concatenate","text":"concatenate(\n    F::CTFlowsODE.OptimalControlFlow,\n    g::Tuple{Real, TF<:CTFlowsODE.OptimalControlFlow}\n) -> CTFlowsODE.OptimalControlFlow\n\n\nConcatenate two OptimalControlFlows at a switching time.\n\nArguments\n\nF::OptimalControlFlow\ng::Tuple{ctNumber,OptimalControlFlow}\n\nReturns\n\nA combined flow with switched dynamics and feedback control.\n\nExample\n\njulia> F * (1.0, G)\n\n\n\n\n\n","category":"method"},{"location":"concatenation.html","page":"Concatenation","title":"Concatenation","text":"","category":"page"},{"location":"function.html#Function","page":"Function","title":"Function","text":"","category":"section"},{"location":"function.html#Index","page":"Function","title":"Index","text":"","category":"section"},{"location":"function.html","page":"Function","title":"Function","text":"Pages   = [\"function.md\"]\nModules = [CTFlows, CTFlowsODE]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"function.html","page":"Function","title":"Function","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTFlows\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTFlows\njulia> x = 1\njulia> CTFlows.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTFlows: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"function.html#Documentation","page":"Function","title":"Documentation","text":"","category":"section"},{"location":"function.html#CTFlows.Flow-Tuple{Function}","page":"Function","title":"CTFlows.Flow","text":"Flow(\n    dyn::Function;\n    autonomous,\n    variable,\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.ODEFlow\n\n\nConstructs a Flow from a user-defined dynamical system given as a Julia function.\n\nThis high-level interface handles:\n\nautonomous and non-autonomous systems,\npresence or absence of additional variables (v),\nselection of ODE solvers and tolerances,\nand integrates with the CTFlows event system (e.g., jumps, callbacks).\n\nArguments\n\ndyn: A function defining the vector field. Its signature must match the values of autonomous and variable.\nautonomous: Whether the dynamics are time-independent (false by default).\nvariable: Whether the dynamics depend on a control or parameter v.\nalg, abstol, reltol, saveat, internalnorm: Solver settings passed to OrdinaryDiffEq.solve.\nkwargs_Flow: Additional keyword arguments passed to the solver.\n\nReturns\n\nAn ODEFlow object, wrapping both the full solver and its right-hand side (RHS).\n\nSupported Function Signatures for dyn\n\nDepending on the (autonomous, variable) flags:\n\n(false, false): dyn(x)\n(false, true):  dyn(x, v)\n(true, false):  dyn(t, x)\n(true, true):   dyn(t, x, v)\n\nExample\n\njulia> dyn(t, x, v) = [-x[1] + v[1] * sin(t)]\njulia> flow = CTFlows.Flow(dyn; autonomous=true, variable=true)\njulia> xT = flow((0.0, 1.0), [1.0], [0.1])\n\n\n\n\n\n","category":"method"},{"location":"function.html#CTFlowsODE.ode_usage-NTuple{5, Any}","page":"Function","title":"CTFlowsODE.ode_usage","text":"ode_usage(\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm;\n    kwargs_Flow...\n) -> Any\n\n\nBuilds a solver function for general ODE problems using OrdinaryDiffEq.solve.\n\nThis utility constructs a reusable solver function that:\n\nhandles optional parameters and control variables,\nintegrates with event-based CallbackSet mechanisms (including jumps),\nsupports both full solutions and one-step propagation,\nmerges solver-specific and global keyword arguments.\n\nReturns\n\nA function f that can be called in two ways:\n\nf(tspan, x0, v=nothing; kwargs...) returns the full ODESolution.\nf(t0, x0, tf, v=nothing; kwargs...) returns only the final state x(tf).\n\nArguments\n\nalg: The numerical integration algorithm (e.g., Tsit5()).\nabstol: Absolute tolerance for the solver.\nreltol: Relative tolerance for the solver.\nsaveat: Optional time steps for solution saving.\ninternalnorm: Norm function used internally for error control.\nkwargs_Flow: Keyword arguments propagated to the solver (unless overridden).\n\nExample\n\njulia> f = ode_usage(Tsit5(), 1e-6, 1e-6, 0.1, InternalNorm())\njulia> sol = f((0.0, 1.0), [1.0, 0.0], [0.0]; jumps=[], _t_stops_interne=[], DiffEqRHS=my_rhs)\n\n\n\n\n\n","category":"method"},{"location":"function.html","page":"Function","title":"Function","text":"","category":"page"},{"location":"ctflows.html#CTFlows","page":"CTFlows","title":"CTFlows","text":"","category":"section"},{"location":"ctflows.html#Index","page":"CTFlows","title":"Index","text":"","category":"section"},{"location":"ctflows.html","page":"CTFlows","title":"CTFlows","text":"Pages   = [\"ctflow.md\"]\nModules = [CTFlows]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"ctflows.html","page":"CTFlows","title":"CTFlows","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTFlows\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTFlows\njulia> x = 1\njulia> CTFlows.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTFlows: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"ctflows.html#Documentation","page":"CTFlows","title":"Documentation","text":"","category":"section"},{"location":"ctflows.html","page":"CTFlows","title":"CTFlows","text":"","category":"page"},{"location":"hamiltonian.html#Hamiltonian","page":"Hamiltonian","title":"Hamiltonian","text":"","category":"section"},{"location":"hamiltonian.html#Index","page":"Hamiltonian","title":"Index","text":"","category":"section"},{"location":"hamiltonian.html","page":"Hamiltonian","title":"Hamiltonian","text":"Pages   = [\"hamiltonian.md\"]\nModules = [CTFlows, CTFlowsODE]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"hamiltonian.html","page":"Hamiltonian","title":"Hamiltonian","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTFlows\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTFlows\njulia> x = 1\njulia> CTFlows.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTFlows: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"hamiltonian.html#Documentation","page":"Hamiltonian","title":"Documentation","text":"","category":"section"},{"location":"hamiltonian.html#CTFlows.Flow-Tuple{CTFlows.AbstractHamiltonian}","page":"Hamiltonian","title":"CTFlows.Flow","text":"Flow(\n    h::CTFlows.AbstractHamiltonian;\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.HamiltonianFlow\n\n\nConstructs a Hamiltonian flow from a scalar Hamiltonian.\n\nThis method builds a numerical integrator that simulates the evolution of a Hamiltonian system given a Hamiltonian function h(t, x, p, l) or h(x, p).\n\nInternally, it computes the right-hand side of Hamilton’s equations via automatic differentiation and returns a HamiltonianFlow object.\n\nKeyword Arguments\n\nalg, abstol, reltol, saveat, internalnorm: solver options.\nkwargs_Flow...: forwarded to the solver.\n\nExample\n\njulia> H(x, p) = dot(p, p) + dot(x, x)\njulia> flow = CTFlows.Flow(CTFlows.Hamiltonian(H))\njulia> xf, pf = flow(0.0, x0, p0, 1.0)\n\n\n\n\n\n","category":"method"},{"location":"hamiltonian.html#CTFlows.Flow-Tuple{CTFlows.HamiltonianVectorField}","page":"Hamiltonian","title":"CTFlows.Flow","text":"Flow(\n    hv::CTFlows.HamiltonianVectorField;\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.HamiltonianFlow\n\n\nConstructs a Hamiltonian flow from a precomputed Hamiltonian vector field.\n\nThis method assumes you already provide the Hamiltonian vector field (dx/dt, dp/dt) instead of deriving it from a scalar Hamiltonian.\n\nReturns a HamiltonianFlow object that integrates the given system.\n\nKeyword Arguments\n\nalg, abstol, reltol, saveat, internalnorm: solver options.\nkwargs_Flow...: forwarded to the solver.\n\nExample\n\njulia> hv(t, x, p, l) = (∇ₚH, -∇ₓH)\njulia> flow = CTFlows.Flow(CTFlows.HamiltonianVectorField(hv))\njulia> xf, pf = flow(0.0, x0, p0, 1.0, l)\n\n\n\n\n\n","category":"method"},{"location":"hamiltonian.html#CTFlowsODE.hamiltonian_usage-NTuple{5, Any}","page":"Hamiltonian","title":"CTFlowsODE.hamiltonian_usage","text":"hamiltonian_usage(\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm;\n    kwargs_Flow...\n) -> Any\n\n\nConstructs a solver function for Hamiltonian systems, with configurable solver options.\n\nReturns a callable object that integrates Hamilton's equations from an initial state (x0, p0) over a time span tspan = (t0, tf), with optional external parameters.\n\nThe returned function has two methods:\n\nf(tspan, x0, p0, v=default_variable; kwargs...) → returns the full trajectory (solution object).\nf(t0, x0, p0, tf, v=default_variable; kwargs...) → returns only the final (x, p) state.\n\nInternally, it uses OrdinaryDiffEq.solve and supports events and callbacks.\n\nArguments\n\nalg: integration algorithm (e.g. Tsit5()).\nabstol, reltol: absolute and relative tolerances.\nsaveat: time points for saving.\ninternalnorm: norm used for adaptive integration.\nkwargs_Flow...: additional keyword arguments for the solver.\n\nExample\n\njulia> flowfun = hamiltonian_usage(Tsit5(), 1e-8, 1e-8, 0.1, norm)\njulia> xf, pf = flowfun(0.0, x0, p0, 1.0)\n\n\n\n\n\n","category":"method"},{"location":"hamiltonian.html#CTFlowsODE.rhs-Tuple{CTFlows.AbstractHamiltonian}","page":"Hamiltonian","title":"CTFlowsODE.rhs","text":"rhs(\n    h::CTFlows.AbstractHamiltonian\n) -> CTFlowsODE.var\"#rhs!#43\"{<:CTFlows.AbstractHamiltonian{TD, VD}} where {TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\n\nConstructs the right-hand side of Hamilton's equations from a scalar Hamiltonian function.\n\nGiven a Hamiltonian h(t, x, p, l) (or h(x, p) in the autonomous case), returns an in-place function rhs!(dz, z, v, t) suitable for numerical integration.\n\nThis function computes the canonical Hamiltonian vector field using automatic differentiation:\n\ndz[1:n]     =  ∂H/∂p\ndz[n+1:2n]  = -∂H/∂x\n\nArguments\n\nh: a subtype of CTFlows.AbstractHamiltonian defining the scalar Hamiltonian.\n\nReturns\n\nrhs!: a function for use in an ODE solver.\n\n\n\n\n\n","category":"method"},{"location":"hamiltonian.html","page":"Hamiltonian","title":"Hamiltonian","text":"","category":"page"},{"location":"ext_utils.html#Extension-Utils","page":"Extension Utils","title":"Extension Utils","text":"","category":"section"},{"location":"ext_utils.html#Index","page":"Extension Utils","title":"Index","text":"","category":"section"},{"location":"ext_utils.html","page":"Extension Utils","title":"Extension Utils","text":"Pages   = [\"ext_utils.md\"]\nModules = [CTFlows, CTFlowsODE]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"ext_utils.html","page":"Extension Utils","title":"Extension Utils","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTFlows\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTFlows\njulia> x = 1\njulia> CTFlows.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTFlows: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"ext_utils.html#Documentation","page":"Extension Utils","title":"Documentation","text":"","category":"section"},{"location":"ext_utils.html#CTFlowsODE.__callbacks-NTuple{5, Any}","page":"Extension Utils","title":"CTFlowsODE.__callbacks","text":"__callbacks(\n    callback,\n    jumps,\n    _rg,\n    _t_stops_interne,\n    tstops\n) -> Tuple{Any, Any}\n\n\nConstructs the combined callback and stopping times for flow integration.\n\nThis internal utility assembles a CallbackSet for the ODE integrator, handling both:\n\ndiscrete jumps in the state or costate (via VectorContinuousCallback), and\nuser-defined callbacks.\n\nAdditionally, it merges stopping times into a sorted, unique list used for tstops.\n\nArguments\n\ncallback: A user-defined callback (e.g. for logging or monitoring).\njumps: A vector of tuples (t, η) representing discrete updates at time t.\n_rg: An optional index range where the jump η should be applied (e.g. only to p in (x, p)).\n_t_stops_interne: Internal list of event times (mutable, extended in place).\ntstops: Additional stopping times from the outer solver context.\n\nReturns\n\ncb: A CallbackSet combining jumps and user callback.\nt_stops_all: Sorted and deduplicated list of all stopping times.\n\nExample\n\njulia> cb, tstops = __callbacks(mycb, [(1.0, [0.0, -1.0])], 3:4, [], [2.0])\n\n\n\n\n\n","category":"method"},{"location":"ext_utils.html","page":"Extension Utils","title":"Extension Utils","text":"","category":"page"},{"location":"index.html#CTFlows.jl","page":"Introduction","title":"CTFlows.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The CTFlows.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The root package is OptimalControl.jl which aims to provide tools to model and solve optimal control problems with ordinary differential equations by direct and indirect methods.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"API Documentation","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Pages = Main.API_PAGES\nDepth = 1","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"ext_default.html#Extension-Default","page":"Extension Default","title":"Extension Default","text":"","category":"section"},{"location":"ext_default.html#Index","page":"Extension Default","title":"Index","text":"","category":"section"},{"location":"ext_default.html","page":"Extension Default","title":"Extension Default","text":"Pages   = [\"ext_default.md\"]\nModules = [CTFlows, CTFlowsODE]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"ext_default.html","page":"Extension Default","title":"Extension Default","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTFlows\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTFlows\njulia> x = 1\njulia> CTFlows.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTFlows: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"ext_default.html#Documentation","page":"Extension Default","title":"Documentation","text":"","category":"section"},{"location":"ext_default.html#CTFlowsODE.__abstol-Tuple{}","page":"Extension Default","title":"CTFlowsODE.__abstol","text":"__abstol() -> Float64\n\n\nDefault absolute tolerance for ODE solvers.\n\nSee abstol from DifferentialEquations.\n\n\n\n\n\n","category":"method"},{"location":"ext_default.html#CTFlowsODE.__alg-Tuple{}","page":"Extension Default","title":"CTFlowsODE.__alg","text":"__alg(\n\n) -> Tsit5{typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!), Static.False}\n\n\nDefault algorithm for ODE solvers.\n\nSee alg from DifferentialEquations.\n\n\n\n\n\n","category":"method"},{"location":"ext_default.html#CTFlowsODE.__callback-Tuple{}","page":"Extension Default","title":"CTFlowsODE.__callback","text":"__callback()\n\n\nSee callback from DifferentialEquations.\n\n\n\n\n\n","category":"method"},{"location":"ext_default.html#CTFlowsODE.__internalnorm-Tuple{}","page":"Extension Default","title":"CTFlowsODE.__internalnorm","text":"__internalnorm() -> CTFlowsODE.var\"#1#2\"\n\n\nDefault internal norm.\n\n\n\n\n\n","category":"method"},{"location":"ext_default.html#CTFlowsODE.__reltol-Tuple{}","page":"Extension Default","title":"CTFlowsODE.__reltol","text":"__reltol() -> Float64\n\n\nDefault relative tolerance for ODE solvers.\n\nSee reltol from DifferentialEquations.\n\n\n\n\n\n","category":"method"},{"location":"ext_default.html#CTFlowsODE.__saveat-Tuple{}","page":"Extension Default","title":"CTFlowsODE.__saveat","text":"__saveat() -> Vector{Any}\n\n\nSee saveat from DifferentialEquations.\n\n\n\n\n\n","category":"method"},{"location":"ext_default.html#CTFlowsODE.__thevariable-NTuple{5, Any}","page":"Extension Default","title":"CTFlowsODE.__thevariable","text":"__thevariable(t0, x0, p0, tf, ocp) -> Any\n\n\nDefault variable from ocp.\n\n\n\n\n\n","category":"method"},{"location":"ext_default.html#CTFlowsODE.__thevariable-Tuple{Any, Any}","page":"Extension Default","title":"CTFlowsODE.__thevariable","text":"__thevariable(x0, p0) -> Vector\n\n\nDefault variable x0, p0.\n\n\n\n\n\n","category":"method"},{"location":"ext_default.html#CTFlowsODE.__thevariable-Tuple{Any}","page":"Extension Default","title":"CTFlowsODE.__thevariable","text":"__thevariable(x0) -> Vector\n\n\nDefault variable from x0.\n\n\n\n\n\n","category":"method"},{"location":"ext_default.html#CTFlowsODE.__tstops-Tuple{}","page":"Extension Default","title":"CTFlowsODE.__tstops","text":"__tstops() -> Vector{Real}\n\n\nSee tstops from DifferentialEquations.\n\n\n\n\n\n","category":"method"},{"location":"ext_default.html","page":"Extension Default","title":"Extension Default","text":"","category":"page"},{"location":"ctflowsode.html#CTFlowsODE","page":"CTFlowsODE","title":"CTFlowsODE","text":"","category":"section"},{"location":"ctflowsode.html#Index","page":"CTFlowsODE","title":"Index","text":"","category":"section"},{"location":"ctflowsode.html","page":"CTFlowsODE","title":"CTFlowsODE","text":"Pages   = [\"ctflowsode.md\"]\nModules = [CTFlows, CTFlowsODE]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"ctflowsode.html","page":"CTFlowsODE","title":"CTFlowsODE","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTFlows\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTFlows\njulia> x = 1\njulia> CTFlows.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTFlows: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"ctflowsode.html#Documentation","page":"CTFlowsODE","title":"Documentation","text":"","category":"section"},{"location":"ctflowsode.html#CTFlowsODE.CoTangent","page":"CTFlowsODE","title":"CTFlowsODE.CoTangent","text":"Alias for CTFlows.ctVector, representing cotangent vectors in continuous-time systems.\n\nUsed for denoting adjoint states or costates in optimal control formulations.\n\n\n\n\n\n","category":"type"},{"location":"ctflowsode.html#CTFlowsODE.DCoTangent","page":"CTFlowsODE","title":"CTFlowsODE.DCoTangent","text":"Alias for CTFlows.ctVector, representing derivative cotangent vectors.\n\nUseful in contexts where second-order information or directional derivatives of costates are required.\n\n\n\n\n\n","category":"type"},{"location":"ctflowsode.html#CTFlowsODE.AbstractFlow","page":"CTFlowsODE","title":"CTFlowsODE.AbstractFlow","text":"Abstract supertype for continuous-time flows.\n\nAbstractFlow{D,U} defines the interface for any flow system with:\n\nD: the type of the differential (typically a vector or matrix),\nU: the type of the state variable.\n\nSubtypes should define at least a right-hand side function for the system's dynamics.\n\n\n\n\n\n","category":"type"},{"location":"ctflowsode.html#CTFlowsODE.__autonomous","page":"CTFlowsODE","title":"CTFlowsODE.__autonomous","text":"Alias for CTFlows.__autonomous, a tag indicating that a flow is autonomous.\n\nUsed internally to specify behavior in constructors or when composing flows.\n\n\n\n\n\n","category":"function"},{"location":"ctflowsode.html#CTFlowsODE.__create_hamiltonian","page":"CTFlowsODE","title":"CTFlowsODE.__create_hamiltonian","text":"Alias for CTFlows.__create_hamiltonian.\n\nConstructs the Hamiltonian function for a given continuous-time optimal control problem. This internal function typically takes an objective, dynamics, and control constraints.\n\n\n\n\n\n","category":"function"},{"location":"ctflowsode.html#CTFlowsODE.__variable","page":"CTFlowsODE","title":"CTFlowsODE.__variable","text":"Alias for CTFlows.__variable, a tag indicating that a flow depends on external variables or is non-autonomous.\n\nUsed to distinguish time-dependent systems or flows with control/state parameterization.\n\n\n\n\n\n","category":"function"},{"location":"ctflowsode.html#CTFlowsODE.ctgradient","page":"CTFlowsODE","title":"CTFlowsODE.ctgradient","text":"Alias for CTFlows.ctgradient, a method to compute the gradient of a scalar function with respect to a state.\n\nIt dispatches appropriately depending on whether the input is a scalar or a vector, and uses ForwardDiff.jl.\n\n\n\n\n\n","category":"function"},{"location":"ctflowsode.html#CTFlowsODE.rg-Tuple{Int64, Int64}","page":"CTFlowsODE","title":"CTFlowsODE.rg","text":"Creates a range i:j, unless i == j, in which case returns i as an integer.\n\nUseful when indexing or slicing arrays with optional single-element flexibility.\n\n\n\n\n\n","category":"method"},{"location":"ctflowsode.html","page":"CTFlowsODE","title":"CTFlowsODE","text":"","category":"page"}]
}
